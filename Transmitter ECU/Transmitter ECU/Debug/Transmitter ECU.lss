
Transmitter ECU.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000bdc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000002e  00800060  00000bdc  00000c70  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000000a  0080008e  0080008e  00000c9e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000c9e  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000218  00000000  00000000  00000cce  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00001573  00000000  00000000  00000ee6  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000705  00000000  00000000  00002459  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000937  00000000  00000000  00002b5e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000518  00000000  00000000  00003498  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000851  00000000  00000000  000039b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000d99  00000000  00000000  00004201  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000001a0  00000000  00000000  00004f9a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 43 00 	jmp	0x86	; 0x86 <__ctors_end>
   4:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
   8:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
   c:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  10:	0c 94 1b 05 	jmp	0xa36	; 0xa36 <__vector_4>
  14:	0c 94 42 05 	jmp	0xa84	; 0xa84 <__vector_5>
  18:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  1c:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  20:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  24:	0c 94 f4 04 	jmp	0x9e8	; 0x9e8 <__vector_9>
  28:	0c 94 a6 04 	jmp	0x94c	; 0x94c <__vector_10>
  2c:	0c 94 cd 04 	jmp	0x99a	; 0x99a <__vector_11>
  30:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  34:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  38:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  3c:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  40:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  44:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  48:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  4c:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  50:	0c 94 60 00 	jmp	0xc0	; 0xc0 <__bad_interrupt>
  54:	d5 03       	fmuls	r21, r21
  56:	df 03       	fmulsu	r21, r23
  58:	e9 03       	fmulsu	r22, r17
  5a:	7f 04       	cpc	r7, r15
  5c:	f3 03       	fmuls	r23, r19
  5e:	7f 04       	cpc	r7, r15
  60:	fd 03       	fmulsu	r23, r21
  62:	07 04       	cpc	r0, r7
  64:	11 04       	cpc	r1, r1
  66:	1b 04       	cpc	r1, r11
  68:	30 04       	cpc	r3, r0
  6a:	3a 04       	cpc	r3, r10
  6c:	44 04       	cpc	r4, r4
  6e:	4e 04       	cpc	r4, r14
  70:	58 04       	cpc	r5, r8
  72:	62 04       	cpc	r6, r2
  74:	6c 04       	cpc	r6, r12
  76:	76 04       	cpc	r7, r6
  78:	b9 05       	cpc	r27, r9
  7a:	80 05       	cpc	r24, r0
  7c:	85 05       	cpc	r24, r5
  7e:	8a 05       	cpc	r24, r10
  80:	8f 05       	cpc	r24, r15
  82:	94 05       	cpc	r25, r4
  84:	a6 05       	cpc	r26, r6

00000086 <__ctors_end>:
  86:	11 24       	eor	r1, r1
  88:	1f be       	out	0x3f, r1	; 63
  8a:	cf e5       	ldi	r28, 0x5F	; 95
  8c:	d8 e0       	ldi	r29, 0x08	; 8
  8e:	de bf       	out	0x3e, r29	; 62
  90:	cd bf       	out	0x3d, r28	; 61

00000092 <__do_copy_data>:
  92:	10 e0       	ldi	r17, 0x00	; 0
  94:	a0 e6       	ldi	r26, 0x60	; 96
  96:	b0 e0       	ldi	r27, 0x00	; 0
  98:	ec ed       	ldi	r30, 0xDC	; 220
  9a:	fb e0       	ldi	r31, 0x0B	; 11
  9c:	02 c0       	rjmp	.+4      	; 0xa2 <__do_copy_data+0x10>
  9e:	05 90       	lpm	r0, Z+
  a0:	0d 92       	st	X+, r0
  a2:	ae 38       	cpi	r26, 0x8E	; 142
  a4:	b1 07       	cpc	r27, r17
  a6:	d9 f7       	brne	.-10     	; 0x9e <__do_copy_data+0xc>

000000a8 <__do_clear_bss>:
  a8:	20 e0       	ldi	r18, 0x00	; 0
  aa:	ae e8       	ldi	r26, 0x8E	; 142
  ac:	b0 e0       	ldi	r27, 0x00	; 0
  ae:	01 c0       	rjmp	.+2      	; 0xb2 <.do_clear_bss_start>

000000b0 <.do_clear_bss_loop>:
  b0:	1d 92       	st	X+, r1

000000b2 <.do_clear_bss_start>:
  b2:	a8 39       	cpi	r26, 0x98	; 152
  b4:	b2 07       	cpc	r27, r18
  b6:	e1 f7       	brne	.-8      	; 0xb0 <.do_clear_bss_loop>
  b8:	0e 94 69 05 	call	0xad2	; 0xad2 <main>
  bc:	0c 94 ec 05 	jmp	0xbd8	; 0xbd8 <_exit>

000000c0 <__bad_interrupt>:
  c0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000c4 <Motor_Init>:
#include "../../MCAL/PWM/PWM.h"
#include "../../MCAL/DIO/DIO_Source/DIO.h"

void Motor_Init(void)
{
	PWM_init(TIMER0);
  c4:	80 e0       	ldi	r24, 0x00	; 0
  c6:	0e 94 da 02 	call	0x5b4	; 0x5b4 <PWM_init>
	PWM_init(TIMER2);
  ca:	81 e0       	ldi	r24, 0x01	; 1
  cc:	0e 94 da 02 	call	0x5b4	; 0x5b4 <PWM_init>
  d0:	08 95       	ret

000000d2 <Motor_move_forward>:
}

void Motor_move_forward(void)
{	//clockwise direction 
	DIO_Set_Channel(MOTOR_A_1);  // left motor
  d2:	82 e0       	ldi	r24, 0x02	; 2
  d4:	0e 94 46 02 	call	0x48c	; 0x48c <DIO_Set_Channel>
	DIO_Clr_Channel(MOTOR_A_2);
  d8:	83 e0       	ldi	r24, 0x03	; 3
  da:	0e 94 8e 02 	call	0x51c	; 0x51c <DIO_Clr_Channel>
	DIO_Set_Channel(MOTOR_B_1);  //right motor
  de:	84 e0       	ldi	r24, 0x04	; 4
  e0:	0e 94 46 02 	call	0x48c	; 0x48c <DIO_Set_Channel>
	DIO_Clr_Channel(MOTOR_B_2);
  e4:	85 e0       	ldi	r24, 0x05	; 5
  e6:	0e 94 8e 02 	call	0x51c	; 0x51c <DIO_Clr_Channel>
  ea:	08 95       	ret

000000ec <Motor_move_backward>:
}

void Motor_move_backward(void)
{
	//counter clockwise direction
	DIO_Set_Channel(MOTOR_A_2);
  ec:	83 e0       	ldi	r24, 0x03	; 3
  ee:	0e 94 46 02 	call	0x48c	; 0x48c <DIO_Set_Channel>
	DIO_Clr_Channel(MOTOR_A_1);
  f2:	82 e0       	ldi	r24, 0x02	; 2
  f4:	0e 94 8e 02 	call	0x51c	; 0x51c <DIO_Clr_Channel>
	DIO_Set_Channel(MOTOR_B_2);
  f8:	85 e0       	ldi	r24, 0x05	; 5
  fa:	0e 94 46 02 	call	0x48c	; 0x48c <DIO_Set_Channel>
	DIO_Clr_Channel(MOTOR_B_1);	
  fe:	84 e0       	ldi	r24, 0x04	; 4
 100:	0e 94 8e 02 	call	0x51c	; 0x51c <DIO_Clr_Channel>
 104:	08 95       	ret

00000106 <Motor_set_speed_left>:
}

void Motor_set_speed_left (uint8 speed)
{	//MOTOR_A
	PWM_SetDutyCycle(speed,TIMER0);
 106:	60 e0       	ldi	r22, 0x00	; 0
 108:	0e 94 fb 02 	call	0x5f6	; 0x5f6 <PWM_SetDutyCycle>
 10c:	08 95       	ret

0000010e <Motor_set_speed_right>:
}

void Motor_set_speed_right (uint8 speed)
{	//MOTOR_B
	PWM_SetDutyCycle(speed,TIMER2);
 10e:	61 e0       	ldi	r22, 0x01	; 1
 110:	0e 94 fb 02 	call	0x5f6	; 0x5f6 <PWM_SetDutyCycle>
 114:	08 95       	ret

00000116 <Motor_stop>:
	Motor_set_speed_left(0);
	Motor_set_speed_right(right_speed);
}
void Motor_stop(void)
{
	Motor_set_speed_left(0);
 116:	80 e0       	ldi	r24, 0x00	; 0
 118:	0e 94 83 00 	call	0x106	; 0x106 <Motor_set_speed_left>
	Motor_set_speed_right(0);
 11c:	80 e0       	ldi	r24, 0x00	; 0
 11e:	0e 94 87 00 	call	0x10e	; 0x10e <Motor_set_speed_right>
 122:	08 95       	ret

00000124 <DIO_set_dir>:
	}
	
}
void DIO_set_dir(channel_id channel)
{
	DIO_CONFIG* channel_ptr = &DIO_CONFIG_ARR[channel];
 124:	90 e0       	ldi	r25, 0x00	; 0
 126:	fc 01       	movw	r30, r24
 128:	ee 0f       	add	r30, r30
 12a:	ff 1f       	adc	r31, r31
 12c:	ee 0f       	add	r30, r30
 12e:	ff 1f       	adc	r31, r31
 130:	e8 0f       	add	r30, r24
 132:	f9 1f       	adc	r31, r25
 134:	e0 5a       	subi	r30, 0xA0	; 160
 136:	ff 4f       	sbci	r31, 0xFF	; 255
	
	switch (channel_ptr->port_name)
 138:	80 81       	ld	r24, Z
 13a:	81 30       	cpi	r24, 0x01	; 1
 13c:	21 f1       	breq	.+72     	; 0x186 <DIO_set_dir+0x62>
 13e:	30 f0       	brcs	.+12     	; 0x14c <DIO_set_dir+0x28>
 140:	82 30       	cpi	r24, 0x02	; 2
 142:	f1 f1       	breq	.+124    	; 0x1c0 <DIO_set_dir+0x9c>
 144:	83 30       	cpi	r24, 0x03	; 3
 146:	09 f4       	brne	.+2      	; 0x14a <DIO_set_dir+0x26>
 148:	58 c0       	rjmp	.+176    	; 0x1fa <DIO_set_dir+0xd6>
 14a:	08 95       	ret
	{
		case PORT_A:
		{
			if (INPUT == channel_ptr->dir)
 14c:	82 81       	ldd	r24, Z+2	; 0x02
 14e:	81 11       	cpse	r24, r1
 150:	0d c0       	rjmp	.+26     	; 0x16c <DIO_set_dir+0x48>
			{
				CLR_BIT(DDRA,channel_ptr->pin_num);
 152:	2a b3       	in	r18, 0x1a	; 26
 154:	81 e0       	ldi	r24, 0x01	; 1
 156:	90 e0       	ldi	r25, 0x00	; 0
 158:	01 80       	ldd	r0, Z+1	; 0x01
 15a:	02 c0       	rjmp	.+4      	; 0x160 <DIO_set_dir+0x3c>
 15c:	88 0f       	add	r24, r24
 15e:	99 1f       	adc	r25, r25
 160:	0a 94       	dec	r0
 162:	e2 f7       	brpl	.-8      	; 0x15c <DIO_set_dir+0x38>
 164:	80 95       	com	r24
 166:	82 23       	and	r24, r18
 168:	8a bb       	out	0x1a, r24	; 26
 16a:	08 95       	ret
			}
			else
			{
				SET_BIT(DDRA,channel_ptr->pin_num);
 16c:	4a b3       	in	r20, 0x1a	; 26
 16e:	21 e0       	ldi	r18, 0x01	; 1
 170:	30 e0       	ldi	r19, 0x00	; 0
 172:	c9 01       	movw	r24, r18
 174:	01 80       	ldd	r0, Z+1	; 0x01
 176:	02 c0       	rjmp	.+4      	; 0x17c <DIO_set_dir+0x58>
 178:	88 0f       	add	r24, r24
 17a:	99 1f       	adc	r25, r25
 17c:	0a 94       	dec	r0
 17e:	e2 f7       	brpl	.-8      	; 0x178 <DIO_set_dir+0x54>
 180:	84 2b       	or	r24, r20
 182:	8a bb       	out	0x1a, r24	; 26
 184:	08 95       	ret
			}
		}break;
		case PORT_B:
		{
			if (INPUT == channel_ptr->dir)
 186:	82 81       	ldd	r24, Z+2	; 0x02
 188:	81 11       	cpse	r24, r1
 18a:	0d c0       	rjmp	.+26     	; 0x1a6 <DIO_set_dir+0x82>
			{
				CLR_BIT(DDRB,channel_ptr->pin_num);
 18c:	27 b3       	in	r18, 0x17	; 23
 18e:	81 e0       	ldi	r24, 0x01	; 1
 190:	90 e0       	ldi	r25, 0x00	; 0
 192:	01 80       	ldd	r0, Z+1	; 0x01
 194:	02 c0       	rjmp	.+4      	; 0x19a <DIO_set_dir+0x76>
 196:	88 0f       	add	r24, r24
 198:	99 1f       	adc	r25, r25
 19a:	0a 94       	dec	r0
 19c:	e2 f7       	brpl	.-8      	; 0x196 <DIO_set_dir+0x72>
 19e:	80 95       	com	r24
 1a0:	82 23       	and	r24, r18
 1a2:	87 bb       	out	0x17, r24	; 23
 1a4:	08 95       	ret
			}
			else
			{
				SET_BIT(DDRB,channel_ptr->pin_num);
 1a6:	47 b3       	in	r20, 0x17	; 23
 1a8:	21 e0       	ldi	r18, 0x01	; 1
 1aa:	30 e0       	ldi	r19, 0x00	; 0
 1ac:	c9 01       	movw	r24, r18
 1ae:	01 80       	ldd	r0, Z+1	; 0x01
 1b0:	02 c0       	rjmp	.+4      	; 0x1b6 <DIO_set_dir+0x92>
 1b2:	88 0f       	add	r24, r24
 1b4:	99 1f       	adc	r25, r25
 1b6:	0a 94       	dec	r0
 1b8:	e2 f7       	brpl	.-8      	; 0x1b2 <DIO_set_dir+0x8e>
 1ba:	84 2b       	or	r24, r20
 1bc:	87 bb       	out	0x17, r24	; 23
 1be:	08 95       	ret
			}
		}break;
		case PORT_C:
		{
			if (INPUT == channel_ptr->dir)
 1c0:	82 81       	ldd	r24, Z+2	; 0x02
 1c2:	81 11       	cpse	r24, r1
 1c4:	0d c0       	rjmp	.+26     	; 0x1e0 <DIO_set_dir+0xbc>
			{
				CLR_BIT(DDRC,channel_ptr->pin_num);
 1c6:	24 b3       	in	r18, 0x14	; 20
 1c8:	81 e0       	ldi	r24, 0x01	; 1
 1ca:	90 e0       	ldi	r25, 0x00	; 0
 1cc:	01 80       	ldd	r0, Z+1	; 0x01
 1ce:	02 c0       	rjmp	.+4      	; 0x1d4 <DIO_set_dir+0xb0>
 1d0:	88 0f       	add	r24, r24
 1d2:	99 1f       	adc	r25, r25
 1d4:	0a 94       	dec	r0
 1d6:	e2 f7       	brpl	.-8      	; 0x1d0 <DIO_set_dir+0xac>
 1d8:	80 95       	com	r24
 1da:	82 23       	and	r24, r18
 1dc:	84 bb       	out	0x14, r24	; 20
 1de:	08 95       	ret
			}
			else
			{
				SET_BIT(DDRC,channel_ptr->pin_num);
 1e0:	44 b3       	in	r20, 0x14	; 20
 1e2:	21 e0       	ldi	r18, 0x01	; 1
 1e4:	30 e0       	ldi	r19, 0x00	; 0
 1e6:	c9 01       	movw	r24, r18
 1e8:	01 80       	ldd	r0, Z+1	; 0x01
 1ea:	02 c0       	rjmp	.+4      	; 0x1f0 <DIO_set_dir+0xcc>
 1ec:	88 0f       	add	r24, r24
 1ee:	99 1f       	adc	r25, r25
 1f0:	0a 94       	dec	r0
 1f2:	e2 f7       	brpl	.-8      	; 0x1ec <DIO_set_dir+0xc8>
 1f4:	84 2b       	or	r24, r20
 1f6:	84 bb       	out	0x14, r24	; 20
 1f8:	08 95       	ret
			}
		}break;
		case PORT_D:
		{
			if (INPUT == channel_ptr->dir)
 1fa:	82 81       	ldd	r24, Z+2	; 0x02
 1fc:	81 11       	cpse	r24, r1
 1fe:	0e c0       	rjmp	.+28     	; 0x21c <DIO_set_dir+0xf8>
			{
				CLR_BIT(DDRD,channel_ptr->pin_num);
 200:	41 b3       	in	r20, 0x11	; 17
 202:	21 e0       	ldi	r18, 0x01	; 1
 204:	30 e0       	ldi	r19, 0x00	; 0
 206:	c9 01       	movw	r24, r18
 208:	01 80       	ldd	r0, Z+1	; 0x01
 20a:	02 c0       	rjmp	.+4      	; 0x210 <DIO_set_dir+0xec>
 20c:	88 0f       	add	r24, r24
 20e:	99 1f       	adc	r25, r25
 210:	0a 94       	dec	r0
 212:	e2 f7       	brpl	.-8      	; 0x20c <DIO_set_dir+0xe8>
 214:	80 95       	com	r24
 216:	84 23       	and	r24, r20
 218:	81 bb       	out	0x11, r24	; 17
 21a:	08 95       	ret
			}
			else
			{
				SET_BIT(DDRD,channel_ptr->pin_num);
 21c:	41 b3       	in	r20, 0x11	; 17
 21e:	21 e0       	ldi	r18, 0x01	; 1
 220:	30 e0       	ldi	r19, 0x00	; 0
 222:	c9 01       	movw	r24, r18
 224:	01 80       	ldd	r0, Z+1	; 0x01
 226:	02 c0       	rjmp	.+4      	; 0x22c <DIO_set_dir+0x108>
 228:	88 0f       	add	r24, r24
 22a:	99 1f       	adc	r25, r25
 22c:	0a 94       	dec	r0
 22e:	e2 f7       	brpl	.-8      	; 0x228 <DIO_set_dir+0x104>
 230:	84 2b       	or	r24, r20
 232:	81 bb       	out	0x11, r24	; 17
 234:	08 95       	ret

00000236 <DIO_Write>:
		}break;
	}
}
void DIO_Write(channel_id channel, uint8 value)
{
	DIO_CONFIG* channel_ptr = &DIO_CONFIG_ARR[channel];
 236:	90 e0       	ldi	r25, 0x00	; 0
 238:	fc 01       	movw	r30, r24
 23a:	ee 0f       	add	r30, r30
 23c:	ff 1f       	adc	r31, r31
 23e:	ee 0f       	add	r30, r30
 240:	ff 1f       	adc	r31, r31
 242:	8e 0f       	add	r24, r30
 244:	9f 1f       	adc	r25, r31
 246:	fc 01       	movw	r30, r24
 248:	e0 5a       	subi	r30, 0xA0	; 160
 24a:	ff 4f       	sbci	r31, 0xFF	; 255
	switch (channel_ptr->port_name)
 24c:	80 81       	ld	r24, Z
 24e:	81 30       	cpi	r24, 0x01	; 1
 250:	19 f1       	breq	.+70     	; 0x298 <DIO_Write+0x62>
 252:	30 f0       	brcs	.+12     	; 0x260 <DIO_Write+0x2a>
 254:	82 30       	cpi	r24, 0x02	; 2
 256:	e1 f1       	breq	.+120    	; 0x2d0 <DIO_Write+0x9a>
 258:	83 30       	cpi	r24, 0x03	; 3
 25a:	09 f4       	brne	.+2      	; 0x25e <DIO_Write+0x28>
 25c:	55 c0       	rjmp	.+170    	; 0x308 <DIO_Write+0xd2>
 25e:	08 95       	ret
	{
		case PORT_A:
		{
			if (HIGH == value)
 260:	61 30       	cpi	r22, 0x01	; 1
 262:	69 f4       	brne	.+26     	; 0x27e <DIO_Write+0x48>
			{
				SET_BIT(PORTA,channel_ptr->pin_num);
 264:	4b b3       	in	r20, 0x1b	; 27
 266:	21 e0       	ldi	r18, 0x01	; 1
 268:	30 e0       	ldi	r19, 0x00	; 0
 26a:	c9 01       	movw	r24, r18
 26c:	01 80       	ldd	r0, Z+1	; 0x01
 26e:	02 c0       	rjmp	.+4      	; 0x274 <DIO_Write+0x3e>
 270:	88 0f       	add	r24, r24
 272:	99 1f       	adc	r25, r25
 274:	0a 94       	dec	r0
 276:	e2 f7       	brpl	.-8      	; 0x270 <DIO_Write+0x3a>
 278:	84 2b       	or	r24, r20
 27a:	8b bb       	out	0x1b, r24	; 27
 27c:	08 95       	ret
			}
			else
			{
				CLR_BIT(PORTA,channel_ptr->pin_num);
 27e:	2b b3       	in	r18, 0x1b	; 27
 280:	81 e0       	ldi	r24, 0x01	; 1
 282:	90 e0       	ldi	r25, 0x00	; 0
 284:	01 80       	ldd	r0, Z+1	; 0x01
 286:	02 c0       	rjmp	.+4      	; 0x28c <DIO_Write+0x56>
 288:	88 0f       	add	r24, r24
 28a:	99 1f       	adc	r25, r25
 28c:	0a 94       	dec	r0
 28e:	e2 f7       	brpl	.-8      	; 0x288 <DIO_Write+0x52>
 290:	80 95       	com	r24
 292:	82 23       	and	r24, r18
 294:	8b bb       	out	0x1b, r24	; 27
 296:	08 95       	ret
			}
		}break;
		case PORT_B:
		{
			if (HIGH == value)
 298:	61 30       	cpi	r22, 0x01	; 1
 29a:	69 f4       	brne	.+26     	; 0x2b6 <DIO_Write+0x80>
			{
				SET_BIT(PORTB,channel_ptr->pin_num);
 29c:	48 b3       	in	r20, 0x18	; 24
 29e:	21 e0       	ldi	r18, 0x01	; 1
 2a0:	30 e0       	ldi	r19, 0x00	; 0
 2a2:	c9 01       	movw	r24, r18
 2a4:	01 80       	ldd	r0, Z+1	; 0x01
 2a6:	02 c0       	rjmp	.+4      	; 0x2ac <DIO_Write+0x76>
 2a8:	88 0f       	add	r24, r24
 2aa:	99 1f       	adc	r25, r25
 2ac:	0a 94       	dec	r0
 2ae:	e2 f7       	brpl	.-8      	; 0x2a8 <DIO_Write+0x72>
 2b0:	84 2b       	or	r24, r20
 2b2:	88 bb       	out	0x18, r24	; 24
 2b4:	08 95       	ret
			}
			else
			{
				CLR_BIT(PORTB,channel_ptr->pin_num);
 2b6:	28 b3       	in	r18, 0x18	; 24
 2b8:	81 e0       	ldi	r24, 0x01	; 1
 2ba:	90 e0       	ldi	r25, 0x00	; 0
 2bc:	01 80       	ldd	r0, Z+1	; 0x01
 2be:	02 c0       	rjmp	.+4      	; 0x2c4 <DIO_Write+0x8e>
 2c0:	88 0f       	add	r24, r24
 2c2:	99 1f       	adc	r25, r25
 2c4:	0a 94       	dec	r0
 2c6:	e2 f7       	brpl	.-8      	; 0x2c0 <DIO_Write+0x8a>
 2c8:	80 95       	com	r24
 2ca:	82 23       	and	r24, r18
 2cc:	88 bb       	out	0x18, r24	; 24
 2ce:	08 95       	ret
			}
		}break;
		case PORT_C:
		{
			if (HIGH == value)
 2d0:	61 30       	cpi	r22, 0x01	; 1
 2d2:	69 f4       	brne	.+26     	; 0x2ee <DIO_Write+0xb8>
			{
				SET_BIT(PORTC,channel_ptr->pin_num);
 2d4:	45 b3       	in	r20, 0x15	; 21
 2d6:	21 e0       	ldi	r18, 0x01	; 1
 2d8:	30 e0       	ldi	r19, 0x00	; 0
 2da:	c9 01       	movw	r24, r18
 2dc:	01 80       	ldd	r0, Z+1	; 0x01
 2de:	02 c0       	rjmp	.+4      	; 0x2e4 <DIO_Write+0xae>
 2e0:	88 0f       	add	r24, r24
 2e2:	99 1f       	adc	r25, r25
 2e4:	0a 94       	dec	r0
 2e6:	e2 f7       	brpl	.-8      	; 0x2e0 <DIO_Write+0xaa>
 2e8:	84 2b       	or	r24, r20
 2ea:	85 bb       	out	0x15, r24	; 21
 2ec:	08 95       	ret
			}
			else
			{
				CLR_BIT(PORTC,channel_ptr->pin_num);
 2ee:	25 b3       	in	r18, 0x15	; 21
 2f0:	81 e0       	ldi	r24, 0x01	; 1
 2f2:	90 e0       	ldi	r25, 0x00	; 0
 2f4:	01 80       	ldd	r0, Z+1	; 0x01
 2f6:	02 c0       	rjmp	.+4      	; 0x2fc <DIO_Write+0xc6>
 2f8:	88 0f       	add	r24, r24
 2fa:	99 1f       	adc	r25, r25
 2fc:	0a 94       	dec	r0
 2fe:	e2 f7       	brpl	.-8      	; 0x2f8 <DIO_Write+0xc2>
 300:	80 95       	com	r24
 302:	82 23       	and	r24, r18
 304:	85 bb       	out	0x15, r24	; 21
 306:	08 95       	ret
			}
		}break;
		case PORT_D:
		{
			if (HIGH == value)
 308:	61 30       	cpi	r22, 0x01	; 1
 30a:	69 f4       	brne	.+26     	; 0x326 <DIO_Write+0xf0>
			{
				SET_BIT(PORTD,channel_ptr->pin_num);
 30c:	42 b3       	in	r20, 0x12	; 18
 30e:	21 e0       	ldi	r18, 0x01	; 1
 310:	30 e0       	ldi	r19, 0x00	; 0
 312:	c9 01       	movw	r24, r18
 314:	01 80       	ldd	r0, Z+1	; 0x01
 316:	02 c0       	rjmp	.+4      	; 0x31c <DIO_Write+0xe6>
 318:	88 0f       	add	r24, r24
 31a:	99 1f       	adc	r25, r25
 31c:	0a 94       	dec	r0
 31e:	e2 f7       	brpl	.-8      	; 0x318 <DIO_Write+0xe2>
 320:	84 2b       	or	r24, r20
 322:	82 bb       	out	0x12, r24	; 18
 324:	08 95       	ret
			}
			else
			{
				CLR_BIT(PORTD,channel_ptr->pin_num);
 326:	22 b3       	in	r18, 0x12	; 18
 328:	81 e0       	ldi	r24, 0x01	; 1
 32a:	90 e0       	ldi	r25, 0x00	; 0
 32c:	01 80       	ldd	r0, Z+1	; 0x01
 32e:	02 c0       	rjmp	.+4      	; 0x334 <DIO_Write+0xfe>
 330:	88 0f       	add	r24, r24
 332:	99 1f       	adc	r25, r25
 334:	0a 94       	dec	r0
 336:	e2 f7       	brpl	.-8      	; 0x330 <DIO_Write+0xfa>
 338:	80 95       	com	r24
 33a:	82 23       	and	r24, r18
 33c:	82 bb       	out	0x12, r24	; 18
 33e:	08 95       	ret

00000340 <DIO_pullup>:
		}break;
	}
}
void DIO_pullup(channel_id channel)
{
	DIO_CONFIG* channel_ptr = &DIO_CONFIG_ARR[channel];
 340:	90 e0       	ldi	r25, 0x00	; 0
 342:	fc 01       	movw	r30, r24
 344:	ee 0f       	add	r30, r30
 346:	ff 1f       	adc	r31, r31
 348:	ee 0f       	add	r30, r30
 34a:	ff 1f       	adc	r31, r31
 34c:	e8 0f       	add	r30, r24
 34e:	f9 1f       	adc	r31, r25
 350:	e0 5a       	subi	r30, 0xA0	; 160
 352:	ff 4f       	sbci	r31, 0xFF	; 255
	switch (channel_ptr->port_name)
 354:	80 81       	ld	r24, Z
 356:	81 30       	cpi	r24, 0x01	; 1
 358:	21 f1       	breq	.+72     	; 0x3a2 <DIO_pullup+0x62>
 35a:	30 f0       	brcs	.+12     	; 0x368 <DIO_pullup+0x28>
 35c:	82 30       	cpi	r24, 0x02	; 2
 35e:	f1 f1       	breq	.+124    	; 0x3dc <DIO_pullup+0x9c>
 360:	83 30       	cpi	r24, 0x03	; 3
 362:	09 f4       	brne	.+2      	; 0x366 <DIO_pullup+0x26>
 364:	58 c0       	rjmp	.+176    	; 0x416 <DIO_pullup+0xd6>
 366:	08 95       	ret
	{
		case PORT_A:
		{
			if (ENABLE_PULLUP == channel_ptr->pullup_state)
 368:	84 81       	ldd	r24, Z+4	; 0x04
 36a:	81 30       	cpi	r24, 0x01	; 1
 36c:	69 f4       	brne	.+26     	; 0x388 <DIO_pullup+0x48>
			{
				SET_BIT(PORTA,channel_ptr->pin_num);
 36e:	4b b3       	in	r20, 0x1b	; 27
 370:	21 e0       	ldi	r18, 0x01	; 1
 372:	30 e0       	ldi	r19, 0x00	; 0
 374:	c9 01       	movw	r24, r18
 376:	01 80       	ldd	r0, Z+1	; 0x01
 378:	02 c0       	rjmp	.+4      	; 0x37e <DIO_pullup+0x3e>
 37a:	88 0f       	add	r24, r24
 37c:	99 1f       	adc	r25, r25
 37e:	0a 94       	dec	r0
 380:	e2 f7       	brpl	.-8      	; 0x37a <DIO_pullup+0x3a>
 382:	84 2b       	or	r24, r20
 384:	8b bb       	out	0x1b, r24	; 27
 386:	08 95       	ret
			}
			else
			{
				CLR_BIT(PORTA,channel_ptr->pin_num);
 388:	2b b3       	in	r18, 0x1b	; 27
 38a:	81 e0       	ldi	r24, 0x01	; 1
 38c:	90 e0       	ldi	r25, 0x00	; 0
 38e:	01 80       	ldd	r0, Z+1	; 0x01
 390:	02 c0       	rjmp	.+4      	; 0x396 <DIO_pullup+0x56>
 392:	88 0f       	add	r24, r24
 394:	99 1f       	adc	r25, r25
 396:	0a 94       	dec	r0
 398:	e2 f7       	brpl	.-8      	; 0x392 <DIO_pullup+0x52>
 39a:	80 95       	com	r24
 39c:	82 23       	and	r24, r18
 39e:	8b bb       	out	0x1b, r24	; 27
 3a0:	08 95       	ret
			}			
		}break;
		case PORT_B:
		{
			if (ENABLE_PULLUP == channel_ptr->pullup_state)
 3a2:	84 81       	ldd	r24, Z+4	; 0x04
 3a4:	81 30       	cpi	r24, 0x01	; 1
 3a6:	69 f4       	brne	.+26     	; 0x3c2 <DIO_pullup+0x82>
			{
				SET_BIT(PORTB,channel_ptr->pin_num);
 3a8:	48 b3       	in	r20, 0x18	; 24
 3aa:	21 e0       	ldi	r18, 0x01	; 1
 3ac:	30 e0       	ldi	r19, 0x00	; 0
 3ae:	c9 01       	movw	r24, r18
 3b0:	01 80       	ldd	r0, Z+1	; 0x01
 3b2:	02 c0       	rjmp	.+4      	; 0x3b8 <DIO_pullup+0x78>
 3b4:	88 0f       	add	r24, r24
 3b6:	99 1f       	adc	r25, r25
 3b8:	0a 94       	dec	r0
 3ba:	e2 f7       	brpl	.-8      	; 0x3b4 <DIO_pullup+0x74>
 3bc:	84 2b       	or	r24, r20
 3be:	88 bb       	out	0x18, r24	; 24
 3c0:	08 95       	ret
			}
			else
			{
				CLR_BIT(PORTB,channel_ptr->pin_num);
 3c2:	28 b3       	in	r18, 0x18	; 24
 3c4:	81 e0       	ldi	r24, 0x01	; 1
 3c6:	90 e0       	ldi	r25, 0x00	; 0
 3c8:	01 80       	ldd	r0, Z+1	; 0x01
 3ca:	02 c0       	rjmp	.+4      	; 0x3d0 <DIO_pullup+0x90>
 3cc:	88 0f       	add	r24, r24
 3ce:	99 1f       	adc	r25, r25
 3d0:	0a 94       	dec	r0
 3d2:	e2 f7       	brpl	.-8      	; 0x3cc <DIO_pullup+0x8c>
 3d4:	80 95       	com	r24
 3d6:	82 23       	and	r24, r18
 3d8:	88 bb       	out	0x18, r24	; 24
 3da:	08 95       	ret
			}
		}break;
		case PORT_C:
		{
			if (ENABLE_PULLUP == channel_ptr->pullup_state)
 3dc:	84 81       	ldd	r24, Z+4	; 0x04
 3de:	81 30       	cpi	r24, 0x01	; 1
 3e0:	69 f4       	brne	.+26     	; 0x3fc <DIO_pullup+0xbc>
			{
				SET_BIT(PORTC,channel_ptr->pin_num);
 3e2:	45 b3       	in	r20, 0x15	; 21
 3e4:	21 e0       	ldi	r18, 0x01	; 1
 3e6:	30 e0       	ldi	r19, 0x00	; 0
 3e8:	c9 01       	movw	r24, r18
 3ea:	01 80       	ldd	r0, Z+1	; 0x01
 3ec:	02 c0       	rjmp	.+4      	; 0x3f2 <DIO_pullup+0xb2>
 3ee:	88 0f       	add	r24, r24
 3f0:	99 1f       	adc	r25, r25
 3f2:	0a 94       	dec	r0
 3f4:	e2 f7       	brpl	.-8      	; 0x3ee <DIO_pullup+0xae>
 3f6:	84 2b       	or	r24, r20
 3f8:	85 bb       	out	0x15, r24	; 21
 3fa:	08 95       	ret
			}
			else
			{
				CLR_BIT(PORTC,channel_ptr->pin_num);
 3fc:	25 b3       	in	r18, 0x15	; 21
 3fe:	81 e0       	ldi	r24, 0x01	; 1
 400:	90 e0       	ldi	r25, 0x00	; 0
 402:	01 80       	ldd	r0, Z+1	; 0x01
 404:	02 c0       	rjmp	.+4      	; 0x40a <DIO_pullup+0xca>
 406:	88 0f       	add	r24, r24
 408:	99 1f       	adc	r25, r25
 40a:	0a 94       	dec	r0
 40c:	e2 f7       	brpl	.-8      	; 0x406 <DIO_pullup+0xc6>
 40e:	80 95       	com	r24
 410:	82 23       	and	r24, r18
 412:	85 bb       	out	0x15, r24	; 21
 414:	08 95       	ret
			}
		}break;
		case PORT_D:
		{
			if (ENABLE_PULLUP == channel_ptr->pullup_state)
 416:	84 81       	ldd	r24, Z+4	; 0x04
 418:	81 30       	cpi	r24, 0x01	; 1
 41a:	69 f4       	brne	.+26     	; 0x436 <DIO_pullup+0xf6>
			{
				SET_BIT(PORTD,channel_ptr->pin_num);
 41c:	42 b3       	in	r20, 0x12	; 18
 41e:	21 e0       	ldi	r18, 0x01	; 1
 420:	30 e0       	ldi	r19, 0x00	; 0
 422:	c9 01       	movw	r24, r18
 424:	01 80       	ldd	r0, Z+1	; 0x01
 426:	02 c0       	rjmp	.+4      	; 0x42c <DIO_pullup+0xec>
 428:	88 0f       	add	r24, r24
 42a:	99 1f       	adc	r25, r25
 42c:	0a 94       	dec	r0
 42e:	e2 f7       	brpl	.-8      	; 0x428 <DIO_pullup+0xe8>
 430:	84 2b       	or	r24, r20
 432:	82 bb       	out	0x12, r24	; 18
 434:	08 95       	ret
			}
			else
			{
				CLR_BIT(PORTD,channel_ptr->pin_num);
 436:	22 b3       	in	r18, 0x12	; 18
 438:	81 e0       	ldi	r24, 0x01	; 1
 43a:	90 e0       	ldi	r25, 0x00	; 0
 43c:	01 80       	ldd	r0, Z+1	; 0x01
 43e:	02 c0       	rjmp	.+4      	; 0x444 <DIO_pullup+0x104>
 440:	88 0f       	add	r24, r24
 442:	99 1f       	adc	r25, r25
 444:	0a 94       	dec	r0
 446:	e2 f7       	brpl	.-8      	; 0x440 <DIO_pullup+0x100>
 448:	80 95       	com	r24
 44a:	82 23       	and	r24, r18
 44c:	82 bb       	out	0x12, r24	; 18
 44e:	08 95       	ret

00000450 <DIO_Init>:
 *  Author: Hany
 */ 

#include "DIO.h"
void DIO_Init(void)
{
 450:	1f 93       	push	r17
 452:	cf 93       	push	r28
 454:	df 93       	push	r29
 456:	c3 e6       	ldi	r28, 0x63	; 99
 458:	d0 e0       	ldi	r29, 0x00	; 0
	DIO_CONFIG* channel_ptr = NULL;
	
	for(channel_id channel = 0; channel < number_of_channels; channel++)
 45a:	10 e0       	ldi	r17, 0x00	; 0
	{
		channel_ptr = &DIO_CONFIG_ARR[channel];
		DIO_set_dir(channel);
 45c:	81 2f       	mov	r24, r17
 45e:	0e 94 92 00 	call	0x124	; 0x124 <DIO_set_dir>
 462:	fe 01       	movw	r30, r28
 464:	31 97       	sbiw	r30, 0x01	; 1
		if (OUTPUT == channel_ptr->dir)
 466:	80 81       	ld	r24, Z
 468:	81 30       	cpi	r24, 0x01	; 1
 46a:	29 f4       	brne	.+10     	; 0x476 <DIO_Init+0x26>
		{
			DIO_Write(channel, channel_ptr->init_value);
 46c:	68 81       	ld	r22, Y
 46e:	81 2f       	mov	r24, r17
 470:	0e 94 1b 01 	call	0x236	; 0x236 <DIO_Write>
 474:	03 c0       	rjmp	.+6      	; 0x47c <DIO_Init+0x2c>
		}
		else
		{
			DIO_pullup(channel);
 476:	81 2f       	mov	r24, r17
 478:	0e 94 a0 01 	call	0x340	; 0x340 <DIO_pullup>
#include "DIO.h"
void DIO_Init(void)
{
	DIO_CONFIG* channel_ptr = NULL;
	
	for(channel_id channel = 0; channel < number_of_channels; channel++)
 47c:	1f 5f       	subi	r17, 0xFF	; 255
 47e:	25 96       	adiw	r28, 0x05	; 5
 480:	19 30       	cpi	r17, 0x09	; 9
 482:	61 f7       	brne	.-40     	; 0x45c <DIO_Init+0xc>
			DIO_pullup(channel);
		}
		
	}
	
}
 484:	df 91       	pop	r29
 486:	cf 91       	pop	r28
 488:	1f 91       	pop	r17
 48a:	08 95       	ret

0000048c <DIO_Set_Channel>:
		}break;
	}
}
void DIO_Set_Channel(channel_id channel)
{
	DIO_CONFIG* channel_ptr = &DIO_CONFIG_ARR[channel];
 48c:	90 e0       	ldi	r25, 0x00	; 0
 48e:	fc 01       	movw	r30, r24
 490:	ee 0f       	add	r30, r30
 492:	ff 1f       	adc	r31, r31
 494:	ee 0f       	add	r30, r30
 496:	ff 1f       	adc	r31, r31
 498:	8e 0f       	add	r24, r30
 49a:	9f 1f       	adc	r25, r31
 49c:	fc 01       	movw	r30, r24
 49e:	e0 5a       	subi	r30, 0xA0	; 160
 4a0:	ff 4f       	sbci	r31, 0xFF	; 255
	switch (channel_ptr->port_name)
 4a2:	80 81       	ld	r24, Z
 4a4:	81 30       	cpi	r24, 0x01	; 1
 4a6:	99 f0       	breq	.+38     	; 0x4ce <DIO_Set_Channel+0x42>
 4a8:	28 f0       	brcs	.+10     	; 0x4b4 <DIO_Set_Channel+0x28>
 4aa:	82 30       	cpi	r24, 0x02	; 2
 4ac:	e9 f0       	breq	.+58     	; 0x4e8 <DIO_Set_Channel+0x5c>
 4ae:	83 30       	cpi	r24, 0x03	; 3
 4b0:	41 f1       	breq	.+80     	; 0x502 <DIO_Set_Channel+0x76>
 4b2:	08 95       	ret
	{
		case PORT_A:
		{
			SET_BIT(PORTA,channel_ptr->pin_num);
 4b4:	4b b3       	in	r20, 0x1b	; 27
 4b6:	21 e0       	ldi	r18, 0x01	; 1
 4b8:	30 e0       	ldi	r19, 0x00	; 0
 4ba:	c9 01       	movw	r24, r18
 4bc:	01 80       	ldd	r0, Z+1	; 0x01
 4be:	02 c0       	rjmp	.+4      	; 0x4c4 <DIO_Set_Channel+0x38>
 4c0:	88 0f       	add	r24, r24
 4c2:	99 1f       	adc	r25, r25
 4c4:	0a 94       	dec	r0
 4c6:	e2 f7       	brpl	.-8      	; 0x4c0 <DIO_Set_Channel+0x34>
 4c8:	84 2b       	or	r24, r20
 4ca:	8b bb       	out	0x1b, r24	; 27
		}break;
 4cc:	08 95       	ret
		case PORT_B:
		{
			SET_BIT(PORTB,channel_ptr->pin_num);
 4ce:	48 b3       	in	r20, 0x18	; 24
 4d0:	21 e0       	ldi	r18, 0x01	; 1
 4d2:	30 e0       	ldi	r19, 0x00	; 0
 4d4:	c9 01       	movw	r24, r18
 4d6:	01 80       	ldd	r0, Z+1	; 0x01
 4d8:	02 c0       	rjmp	.+4      	; 0x4de <DIO_Set_Channel+0x52>
 4da:	88 0f       	add	r24, r24
 4dc:	99 1f       	adc	r25, r25
 4de:	0a 94       	dec	r0
 4e0:	e2 f7       	brpl	.-8      	; 0x4da <DIO_Set_Channel+0x4e>
 4e2:	84 2b       	or	r24, r20
 4e4:	88 bb       	out	0x18, r24	; 24
		}break;
 4e6:	08 95       	ret
		case PORT_C:
		{
			SET_BIT(PORTC,channel_ptr->pin_num);
 4e8:	45 b3       	in	r20, 0x15	; 21
 4ea:	21 e0       	ldi	r18, 0x01	; 1
 4ec:	30 e0       	ldi	r19, 0x00	; 0
 4ee:	c9 01       	movw	r24, r18
 4f0:	01 80       	ldd	r0, Z+1	; 0x01
 4f2:	02 c0       	rjmp	.+4      	; 0x4f8 <DIO_Set_Channel+0x6c>
 4f4:	88 0f       	add	r24, r24
 4f6:	99 1f       	adc	r25, r25
 4f8:	0a 94       	dec	r0
 4fa:	e2 f7       	brpl	.-8      	; 0x4f4 <DIO_Set_Channel+0x68>
 4fc:	84 2b       	or	r24, r20
 4fe:	85 bb       	out	0x15, r24	; 21
		}break;
 500:	08 95       	ret
		case PORT_D:
		{
			SET_BIT(PORTD,channel_ptr->pin_num);
 502:	42 b3       	in	r20, 0x12	; 18
 504:	21 e0       	ldi	r18, 0x01	; 1
 506:	30 e0       	ldi	r19, 0x00	; 0
 508:	c9 01       	movw	r24, r18
 50a:	01 80       	ldd	r0, Z+1	; 0x01
 50c:	02 c0       	rjmp	.+4      	; 0x512 <DIO_Set_Channel+0x86>
 50e:	88 0f       	add	r24, r24
 510:	99 1f       	adc	r25, r25
 512:	0a 94       	dec	r0
 514:	e2 f7       	brpl	.-8      	; 0x50e <DIO_Set_Channel+0x82>
 516:	84 2b       	or	r24, r20
 518:	82 bb       	out	0x12, r24	; 18
 51a:	08 95       	ret

0000051c <DIO_Clr_Channel>:
		}break;
	}
}
void DIO_Clr_Channel(channel_id channel)
{
	DIO_CONFIG* channel_ptr = &DIO_CONFIG_ARR[channel];
 51c:	90 e0       	ldi	r25, 0x00	; 0
 51e:	fc 01       	movw	r30, r24
 520:	ee 0f       	add	r30, r30
 522:	ff 1f       	adc	r31, r31
 524:	ee 0f       	add	r30, r30
 526:	ff 1f       	adc	r31, r31
 528:	8e 0f       	add	r24, r30
 52a:	9f 1f       	adc	r25, r31
 52c:	fc 01       	movw	r30, r24
 52e:	e0 5a       	subi	r30, 0xA0	; 160
 530:	ff 4f       	sbci	r31, 0xFF	; 255
	switch (channel_ptr->port_name)
 532:	80 81       	ld	r24, Z
 534:	81 30       	cpi	r24, 0x01	; 1
 536:	a1 f0       	breq	.+40     	; 0x560 <DIO_Clr_Channel+0x44>
 538:	28 f0       	brcs	.+10     	; 0x544 <DIO_Clr_Channel+0x28>
 53a:	82 30       	cpi	r24, 0x02	; 2
 53c:	f9 f0       	breq	.+62     	; 0x57c <DIO_Clr_Channel+0x60>
 53e:	83 30       	cpi	r24, 0x03	; 3
 540:	59 f1       	breq	.+86     	; 0x598 <DIO_Clr_Channel+0x7c>
 542:	08 95       	ret
	{
		case PORT_A:
		{
			CLR_BIT(PORTA,channel_ptr->pin_num);
 544:	4b b3       	in	r20, 0x1b	; 27
 546:	21 e0       	ldi	r18, 0x01	; 1
 548:	30 e0       	ldi	r19, 0x00	; 0
 54a:	c9 01       	movw	r24, r18
 54c:	01 80       	ldd	r0, Z+1	; 0x01
 54e:	02 c0       	rjmp	.+4      	; 0x554 <DIO_Clr_Channel+0x38>
 550:	88 0f       	add	r24, r24
 552:	99 1f       	adc	r25, r25
 554:	0a 94       	dec	r0
 556:	e2 f7       	brpl	.-8      	; 0x550 <DIO_Clr_Channel+0x34>
 558:	80 95       	com	r24
 55a:	84 23       	and	r24, r20
 55c:	8b bb       	out	0x1b, r24	; 27
		}break;
 55e:	08 95       	ret
		case PORT_B:
		{
			CLR_BIT(PORTB,channel_ptr->pin_num);
 560:	48 b3       	in	r20, 0x18	; 24
 562:	21 e0       	ldi	r18, 0x01	; 1
 564:	30 e0       	ldi	r19, 0x00	; 0
 566:	c9 01       	movw	r24, r18
 568:	01 80       	ldd	r0, Z+1	; 0x01
 56a:	02 c0       	rjmp	.+4      	; 0x570 <DIO_Clr_Channel+0x54>
 56c:	88 0f       	add	r24, r24
 56e:	99 1f       	adc	r25, r25
 570:	0a 94       	dec	r0
 572:	e2 f7       	brpl	.-8      	; 0x56c <DIO_Clr_Channel+0x50>
 574:	80 95       	com	r24
 576:	84 23       	and	r24, r20
 578:	88 bb       	out	0x18, r24	; 24
		}break;
 57a:	08 95       	ret
		case PORT_C:
		{
			CLR_BIT(PORTC,channel_ptr->pin_num);
 57c:	45 b3       	in	r20, 0x15	; 21
 57e:	21 e0       	ldi	r18, 0x01	; 1
 580:	30 e0       	ldi	r19, 0x00	; 0
 582:	c9 01       	movw	r24, r18
 584:	01 80       	ldd	r0, Z+1	; 0x01
 586:	02 c0       	rjmp	.+4      	; 0x58c <DIO_Clr_Channel+0x70>
 588:	88 0f       	add	r24, r24
 58a:	99 1f       	adc	r25, r25
 58c:	0a 94       	dec	r0
 58e:	e2 f7       	brpl	.-8      	; 0x588 <DIO_Clr_Channel+0x6c>
 590:	80 95       	com	r24
 592:	84 23       	and	r24, r20
 594:	85 bb       	out	0x15, r24	; 21
		}break;
 596:	08 95       	ret
		case PORT_D:
		{
			CLR_BIT(PORTD,channel_ptr->pin_num);
 598:	42 b3       	in	r20, 0x12	; 18
 59a:	21 e0       	ldi	r18, 0x01	; 1
 59c:	30 e0       	ldi	r19, 0x00	; 0
 59e:	c9 01       	movw	r24, r18
 5a0:	01 80       	ldd	r0, Z+1	; 0x01
 5a2:	02 c0       	rjmp	.+4      	; 0x5a8 <DIO_Clr_Channel+0x8c>
 5a4:	88 0f       	add	r24, r24
 5a6:	99 1f       	adc	r25, r25
 5a8:	0a 94       	dec	r0
 5aa:	e2 f7       	brpl	.-8      	; 0x5a4 <DIO_Clr_Channel+0x88>
 5ac:	80 95       	com	r24
 5ae:	84 23       	and	r24, r20
 5b0:	82 bb       	out	0x12, r24	; 18
 5b2:	08 95       	ret

000005b4 <PWM_init>:
#include "../Timer/TIMER.h"

//Initializes the PWM in fast mode
void PWM_init(TIMER_ID timer_number)
{
	switch (timer_number)
 5b4:	88 23       	and	r24, r24
 5b6:	19 f0       	breq	.+6      	; 0x5be <PWM_init+0xa>
 5b8:	81 30       	cpi	r24, 0x01	; 1
 5ba:	79 f0       	breq	.+30     	; 0x5da <PWM_init+0x26>
 5bc:	08 95       	ret
	{
		case TIMER0:
		{								  
			Timer_Disable(TIMER0);
 5be:	80 e0       	ldi	r24, 0x00	; 0
 5c0:	0e 94 9d 04 	call	0x93a	; 0x93a <Timer_Disable>
			Timer_init(TIMER0,FAST_PWM,CLEAR_OC,PRESCALER_1);   // non inverting mode
 5c4:	21 e0       	ldi	r18, 0x01	; 1
 5c6:	41 e0       	ldi	r20, 0x01	; 1
 5c8:	63 e0       	ldi	r22, 0x03	; 3
 5ca:	80 e0       	ldi	r24, 0x00	; 0
 5cc:	0e 94 80 04 	call	0x900	; 0x900 <Timer_init>
			Timer_SetTimerStartValue(TIMER0,ZER0_INITIALIZER);        // init timer value with ZER0 
 5d0:	60 e0       	ldi	r22, 0x00	; 0
 5d2:	80 e0       	ldi	r24, 0x00	; 0
 5d4:	0e 94 94 04 	call	0x928	; 0x928 <Timer_SetTimerStartValue>
		}break;
 5d8:	08 95       	ret
		case TIMER2:
		{
			Timer_Disable(TIMER2);
 5da:	81 e0       	ldi	r24, 0x01	; 1
 5dc:	0e 94 9d 04 	call	0x93a	; 0x93a <Timer_Disable>
			Timer_init(TIMER2,FAST_PWM,CLEAR_OC,PRESCALER_1); 
 5e0:	21 e0       	ldi	r18, 0x01	; 1
 5e2:	41 e0       	ldi	r20, 0x01	; 1
 5e4:	63 e0       	ldi	r22, 0x03	; 3
 5e6:	81 e0       	ldi	r24, 0x01	; 1
 5e8:	0e 94 80 04 	call	0x900	; 0x900 <Timer_init>
			Timer_SetTimerStartValue(TIMER2,ZER0_INITIALIZER);
 5ec:	60 e0       	ldi	r22, 0x00	; 0
 5ee:	81 e0       	ldi	r24, 0x01	; 1
 5f0:	0e 94 94 04 	call	0x928	; 0x928 <Timer_SetTimerStartValue>
 5f4:	08 95       	ret

000005f6 <PWM_SetDutyCycle>:
	}
}

//The duty cycle value. A value between (0 %) and (100 %)
void PWM_SetDutyCycle(uint8 duty_cycle, TIMER_ID timer_number)
{
 5f6:	26 2f       	mov	r18, r22
	uint8 PWM_Actual_Duty;	               //duty cycle is represented by a number from 0->255
	PWM_Actual_Duty = (duty_cycle * TIMER_MAX_VALUE) / DUTY_CYCLE_MAX_VALUE;
 5f8:	3f ef       	ldi	r19, 0xFF	; 255
 5fa:	83 9f       	mul	r24, r19
 5fc:	c0 01       	movw	r24, r0
 5fe:	11 24       	eor	r1, r1
 600:	64 e6       	ldi	r22, 0x64	; 100
 602:	70 e0       	ldi	r23, 0x00	; 0
 604:	0e 94 be 05 	call	0xb7c	; 0xb7c <__divmodhi4>
	/*Output Compare Register OCRx
	* contains an 8-bit value that is continuously compared
	* with the counter value (TCNTx). A match can be used to
	* generate an output compare interrupt
	*/
	switch(timer_number)
 608:	22 23       	and	r18, r18
 60a:	19 f0       	breq	.+6      	; 0x612 <PWM_SetDutyCycle+0x1c>
 60c:	21 30       	cpi	r18, 0x01	; 1
 60e:	19 f0       	breq	.+6      	; 0x616 <PWM_SetDutyCycle+0x20>
 610:	08 95       	ret
	{

		case TIMER0:
		{
			OCR0 = PWM_Actual_Duty;
 612:	6c bf       	out	0x3c, r22	; 60
		}break;
 614:	08 95       	ret

		case TIMER2:
		{
			OCR2 = PWM_Actual_Duty;
 616:	63 bd       	out	0x23, r22	; 35
 618:	08 95       	ret

0000061a <SPI_Init>:
#include "SPI.h"

void SPI_Init(SPI_MODE mode)
{
	
	switch (mode)
 61a:	88 23       	and	r24, r24
 61c:	59 f0       	breq	.+22     	; 0x634 <SPI_Init+0x1a>
 61e:	81 30       	cpi	r24, 0x01	; 1
 620:	71 f4       	brne	.+28     	; 0x63e <SPI_Init+0x24>
	{
		case MASTER:
			{
				SET_BIT(DDRB,P4);             // Slave Select 
 622:	bc 9a       	sbi	0x17, 4	; 23
				SET_BIT(DDRB,P5);            // MOSI (Master output)
 624:	bd 9a       	sbi	0x17, 5	; 23
				SET_BIT(DDRB,P7);           // SCK (Master Clock output)
 626:	bf 9a       	sbi	0x17, 7	; 23
				//CLR_BIT(DDRB,P6);	       // MISO (Master input)
				SET_BIT(SPCR,SPE);        // SPI Enable
 628:	6e 9a       	sbi	0x0d, 6	; 13
				SET_BIT(SPCR,MSTR);      // Master / Slave select
 62a:	6c 9a       	sbi	0x0d, 4	; 13
				SET_BIT(SPCR,SPR0);            // set prescaler to 16
 62c:	68 9a       	sbi	0x0d, 0	; 13
				SET_BIT(SPCR,SPIE);            // enable interrupt
 62e:	6f 9a       	sbi	0x0d, 7	; 13
				SET_BIT(SPCR,DORD);
 630:	6d 9a       	sbi	0x0d, 5	; 13
				
				
			}
			break;
 632:	08 95       	ret
		case SLAVE:
			{
				//CLR_BIT(DDRB,P4);           // Slave Select
				//CLR_BIT(DDRB,P5);          // MOSI (Slave input)
				//CLR_BIT(DDRB,P7);         // SCK (Master Clock output)
				SET_BIT(DDRB,P6);	     // MISO (Slave output)
 634:	be 9a       	sbi	0x17, 6	; 23
				SET_BIT(SPCR,SPE);      // SPI Enable
 636:	6e 9a       	sbi	0x0d, 6	; 13
				CLR_BIT(SPCR,MSTR);    // Master / Slave select
 638:	6c 98       	cbi	0x0d, 4	; 13
				SET_BIT(SPCR,SPIE);            // enable interrupt
 63a:	6f 9a       	sbi	0x0d, 7	; 13
				SET_BIT(SPCR,DORD);
 63c:	6d 9a       	sbi	0x0d, 5	; 13
 63e:	08 95       	ret

00000640 <SPI_Read_Data>:
	while(GET_BIT(SPSR,SPIF)==0);
}

uint8 SPI_Read_Data()
{
	while(GET_BIT(SPSR,SPIF)==0);
 640:	77 9b       	sbis	0x0e, 7	; 14
 642:	fe cf       	rjmp	.-4      	; 0x640 <SPI_Read_Data>
	return SPDR;
 644:	8f b1       	in	r24, 0x0f	; 15
}
 646:	08 95       	ret

00000648 <Timer_Set_Mode>:
	Timer_Set_COM(timer_number,oc_pin_state);
	Timer_Set_Prescaler(timer_number,prescaler);
}
void Timer_Set_Mode(TIMER_ID timer_number, TIMER_MODE mode)
{
	switch (timer_number)
 648:	88 23       	and	r24, r24
 64a:	19 f0       	breq	.+6      	; 0x652 <Timer_Set_Mode+0xa>
 64c:	81 30       	cpi	r24, 0x01	; 1
 64e:	29 f1       	breq	.+74     	; 0x69a <Timer_Set_Mode+0x52>
 650:	08 95       	ret
	{
		case TIMER0:
		{
			switch (mode)
 652:	61 30       	cpi	r22, 0x01	; 1
 654:	69 f0       	breq	.+26     	; 0x670 <Timer_Set_Mode+0x28>
 656:	28 f0       	brcs	.+10     	; 0x662 <Timer_Set_Mode+0x1a>
 658:	62 30       	cpi	r22, 0x02	; 2
 65a:	89 f0       	breq	.+34     	; 0x67e <Timer_Set_Mode+0x36>
 65c:	63 30       	cpi	r22, 0x03	; 3
 65e:	b1 f0       	breq	.+44     	; 0x68c <Timer_Set_Mode+0x44>
 660:	08 95       	ret
			{
				case NORMAL:
				{
					CLR_BIT(TCCR0,WGM00);
 662:	83 b7       	in	r24, 0x33	; 51
 664:	8f 7b       	andi	r24, 0xBF	; 191
 666:	83 bf       	out	0x33, r24	; 51
					CLR_BIT(TCCR0,WGM01);
 668:	83 b7       	in	r24, 0x33	; 51
 66a:	87 7f       	andi	r24, 0xF7	; 247
 66c:	83 bf       	out	0x33, r24	; 51
				}break;
 66e:	08 95       	ret
				case CTC:
				{
					CLR_BIT(TCCR0,WGM00);
 670:	83 b7       	in	r24, 0x33	; 51
 672:	8f 7b       	andi	r24, 0xBF	; 191
 674:	83 bf       	out	0x33, r24	; 51
					SET_BIT(TCCR0,WGM01);
 676:	83 b7       	in	r24, 0x33	; 51
 678:	88 60       	ori	r24, 0x08	; 8
 67a:	83 bf       	out	0x33, r24	; 51
				}break;
 67c:	08 95       	ret
				case PWM_PHASE_CORRECT:
				{
					SET_BIT(TCCR0,WGM00);
 67e:	83 b7       	in	r24, 0x33	; 51
 680:	80 64       	ori	r24, 0x40	; 64
 682:	83 bf       	out	0x33, r24	; 51
					CLR_BIT(TCCR0,WGM01);
 684:	83 b7       	in	r24, 0x33	; 51
 686:	87 7f       	andi	r24, 0xF7	; 247
 688:	83 bf       	out	0x33, r24	; 51
				}break;
 68a:	08 95       	ret
				case FAST_PWM:
				{
					SET_BIT(TCCR0,WGM00);
 68c:	83 b7       	in	r24, 0x33	; 51
 68e:	80 64       	ori	r24, 0x40	; 64
 690:	83 bf       	out	0x33, r24	; 51
					SET_BIT(TCCR0,WGM01);
 692:	83 b7       	in	r24, 0x33	; 51
 694:	88 60       	ori	r24, 0x08	; 8
 696:	83 bf       	out	0x33, r24	; 51
				}break;
 698:	08 95       	ret
			}
		}break;
		case TIMER2:
		{
			switch (mode)
 69a:	61 30       	cpi	r22, 0x01	; 1
 69c:	69 f0       	breq	.+26     	; 0x6b8 <Timer_Set_Mode+0x70>
 69e:	28 f0       	brcs	.+10     	; 0x6aa <Timer_Set_Mode+0x62>
 6a0:	62 30       	cpi	r22, 0x02	; 2
 6a2:	89 f0       	breq	.+34     	; 0x6c6 <Timer_Set_Mode+0x7e>
 6a4:	63 30       	cpi	r22, 0x03	; 3
 6a6:	b1 f0       	breq	.+44     	; 0x6d4 <Timer_Set_Mode+0x8c>
 6a8:	08 95       	ret
			{
				case NORMAL:
				{
					CLR_BIT(TCCR2,WGM20);
 6aa:	85 b5       	in	r24, 0x25	; 37
 6ac:	8f 7b       	andi	r24, 0xBF	; 191
 6ae:	85 bd       	out	0x25, r24	; 37
					CLR_BIT(TCCR2,WGM21);
 6b0:	85 b5       	in	r24, 0x25	; 37
 6b2:	87 7f       	andi	r24, 0xF7	; 247
 6b4:	85 bd       	out	0x25, r24	; 37
				}break;
 6b6:	08 95       	ret
				case CTC:
				{
					CLR_BIT(TCCR2,WGM20);
 6b8:	85 b5       	in	r24, 0x25	; 37
 6ba:	8f 7b       	andi	r24, 0xBF	; 191
 6bc:	85 bd       	out	0x25, r24	; 37
					SET_BIT(TCCR2,WGM21);
 6be:	85 b5       	in	r24, 0x25	; 37
 6c0:	88 60       	ori	r24, 0x08	; 8
 6c2:	85 bd       	out	0x25, r24	; 37
				}break;
 6c4:	08 95       	ret
				case PWM_PHASE_CORRECT:
				{
					SET_BIT(TCCR2,WGM20);
 6c6:	85 b5       	in	r24, 0x25	; 37
 6c8:	80 64       	ori	r24, 0x40	; 64
 6ca:	85 bd       	out	0x25, r24	; 37
					CLR_BIT(TCCR2,WGM21);
 6cc:	85 b5       	in	r24, 0x25	; 37
 6ce:	87 7f       	andi	r24, 0xF7	; 247
 6d0:	85 bd       	out	0x25, r24	; 37
				}break;
 6d2:	08 95       	ret
				case FAST_PWM:
				{
					SET_BIT(TCCR2,WGM20);
 6d4:	85 b5       	in	r24, 0x25	; 37
 6d6:	80 64       	ori	r24, 0x40	; 64
 6d8:	85 bd       	out	0x25, r24	; 37
					SET_BIT(TCCR2,WGM21);
 6da:	85 b5       	in	r24, 0x25	; 37
 6dc:	88 60       	ori	r24, 0x08	; 8
 6de:	85 bd       	out	0x25, r24	; 37
 6e0:	08 95       	ret

000006e2 <Timer_Set_COM>:
		}break;
	}
}
void Timer_Set_COM(TIMER_ID timer_number, COMPARE_OUTPUT_MODE oc_pin_state)
{
	switch (timer_number)
 6e2:	88 23       	and	r24, r24
 6e4:	19 f0       	breq	.+6      	; 0x6ec <Timer_Set_COM+0xa>
 6e6:	81 30       	cpi	r24, 0x01	; 1
 6e8:	41 f1       	breq	.+80     	; 0x73a <Timer_Set_COM+0x58>
 6ea:	08 95       	ret
	{
		case TIMER0:
		{
			switch (oc_pin_state)
 6ec:	61 30       	cpi	r22, 0x01	; 1
 6ee:	69 f0       	breq	.+26     	; 0x70a <Timer_Set_COM+0x28>
 6f0:	28 f0       	brcs	.+10     	; 0x6fc <Timer_Set_COM+0x1a>
 6f2:	62 30       	cpi	r22, 0x02	; 2
 6f4:	89 f0       	breq	.+34     	; 0x718 <Timer_Set_COM+0x36>
 6f6:	63 30       	cpi	r22, 0x03	; 3
 6f8:	b1 f0       	breq	.+44     	; 0x726 <Timer_Set_COM+0x44>
 6fa:	08 95       	ret
			{
				case OC_DISCONNECTED:
				{
					CLR_BIT(TCCR0,COM00);
 6fc:	83 b7       	in	r24, 0x33	; 51
 6fe:	8f 7e       	andi	r24, 0xEF	; 239
 700:	83 bf       	out	0x33, r24	; 51
					CLR_BIT(TCCR0,COM01);
 702:	83 b7       	in	r24, 0x33	; 51
 704:	8f 7d       	andi	r24, 0xDF	; 223
 706:	83 bf       	out	0x33, r24	; 51
				}break;
 708:	08 95       	ret
				case CLEAR_OC:
				{
					CLR_BIT(TCCR0,COM00);
 70a:	83 b7       	in	r24, 0x33	; 51
 70c:	8f 7e       	andi	r24, 0xEF	; 239
 70e:	83 bf       	out	0x33, r24	; 51
					SET_BIT(TCCR0,COM01);
 710:	83 b7       	in	r24, 0x33	; 51
 712:	80 62       	ori	r24, 0x20	; 32
 714:	83 bf       	out	0x33, r24	; 51
				}break;
 716:	08 95       	ret
				case SET_OC:
				{
					SET_BIT(TCCR0,COM00);
 718:	83 b7       	in	r24, 0x33	; 51
 71a:	80 61       	ori	r24, 0x10	; 16
 71c:	83 bf       	out	0x33, r24	; 51
					SET_BIT(TCCR0,COM01);
 71e:	83 b7       	in	r24, 0x33	; 51
 720:	80 62       	ori	r24, 0x20	; 32
 722:	83 bf       	out	0x33, r24	; 51
				}break;
 724:	08 95       	ret
				case TOG_OC:
				{
					if (0 == GET_BIT(TCCR0,WGM00))
 726:	03 b6       	in	r0, 0x33	; 51
 728:	06 fc       	sbrc	r0, 6
 72a:	2d c0       	rjmp	.+90     	; 0x786 <Timer_Set_COM+0xa4>
					{
						SET_BIT(TCCR0,COM00);
 72c:	83 b7       	in	r24, 0x33	; 51
 72e:	80 61       	ori	r24, 0x10	; 16
 730:	83 bf       	out	0x33, r24	; 51
						CLR_BIT(TCCR0,COM01);
 732:	83 b7       	in	r24, 0x33	; 51
 734:	8f 7d       	andi	r24, 0xDF	; 223
 736:	83 bf       	out	0x33, r24	; 51
 738:	08 95       	ret
				}break;
			}
		}break;
		case TIMER2:
		{
			switch (oc_pin_state)
 73a:	61 30       	cpi	r22, 0x01	; 1
 73c:	69 f0       	breq	.+26     	; 0x758 <Timer_Set_COM+0x76>
 73e:	28 f0       	brcs	.+10     	; 0x74a <Timer_Set_COM+0x68>
 740:	62 30       	cpi	r22, 0x02	; 2
 742:	89 f0       	breq	.+34     	; 0x766 <Timer_Set_COM+0x84>
 744:	63 30       	cpi	r22, 0x03	; 3
 746:	b1 f0       	breq	.+44     	; 0x774 <Timer_Set_COM+0x92>
 748:	08 95       	ret
			{
				case OC_DISCONNECTED:
				{
					CLR_BIT(TCCR2,COM20);
 74a:	85 b5       	in	r24, 0x25	; 37
 74c:	8f 7e       	andi	r24, 0xEF	; 239
 74e:	85 bd       	out	0x25, r24	; 37
					CLR_BIT(TCCR2,COM21);
 750:	85 b5       	in	r24, 0x25	; 37
 752:	8f 7d       	andi	r24, 0xDF	; 223
 754:	85 bd       	out	0x25, r24	; 37
				}break;
 756:	08 95       	ret
				case CLEAR_OC:
				{
					CLR_BIT(TCCR2,COM20);
 758:	85 b5       	in	r24, 0x25	; 37
 75a:	8f 7e       	andi	r24, 0xEF	; 239
 75c:	85 bd       	out	0x25, r24	; 37
					SET_BIT(TCCR2,COM21);
 75e:	85 b5       	in	r24, 0x25	; 37
 760:	80 62       	ori	r24, 0x20	; 32
 762:	85 bd       	out	0x25, r24	; 37
				}break;
 764:	08 95       	ret
				case SET_OC:
				{
					SET_BIT(TCCR2,COM20);
 766:	85 b5       	in	r24, 0x25	; 37
 768:	80 61       	ori	r24, 0x10	; 16
 76a:	85 bd       	out	0x25, r24	; 37
					SET_BIT(TCCR2,COM21);
 76c:	85 b5       	in	r24, 0x25	; 37
 76e:	80 62       	ori	r24, 0x20	; 32
 770:	85 bd       	out	0x25, r24	; 37
				}break;
 772:	08 95       	ret
				case TOG_OC:
				{
					if (0 == GET_BIT(TCCR2,WGM20))
 774:	05 b4       	in	r0, 0x25	; 37
 776:	06 fc       	sbrc	r0, 6
 778:	06 c0       	rjmp	.+12     	; 0x786 <Timer_Set_COM+0xa4>
					{
						SET_BIT(TCCR2,COM20);
 77a:	85 b5       	in	r24, 0x25	; 37
 77c:	80 61       	ori	r24, 0x10	; 16
 77e:	85 bd       	out	0x25, r24	; 37
						CLR_BIT(TCCR2,COM21);
 780:	85 b5       	in	r24, 0x25	; 37
 782:	8f 7d       	andi	r24, 0xDF	; 223
 784:	85 bd       	out	0x25, r24	; 37
 786:	08 95       	ret

00000788 <Timer_Set_Prescaler>:
		}break;
	}
}
void Timer_Set_Prescaler(TIMER_ID timer_number, PRESCALER prescaler)
{
	switch (timer_number)
 788:	88 23       	and	r24, r24
 78a:	21 f0       	breq	.+8      	; 0x794 <Timer_Set_Prescaler+0xc>
 78c:	81 30       	cpi	r24, 0x01	; 1
 78e:	09 f4       	brne	.+2      	; 0x792 <Timer_Set_Prescaler+0xa>
 790:	5c c0       	rjmp	.+184    	; 0x84a <Timer_Set_Prescaler+0xc2>
 792:	08 95       	ret
	{
		case TIMER0:
		{
			switch (prescaler)
 794:	86 2f       	mov	r24, r22
 796:	90 e0       	ldi	r25, 0x00	; 0
 798:	8a 30       	cpi	r24, 0x0A	; 10
 79a:	91 05       	cpc	r25, r1
 79c:	08 f0       	brcs	.+2      	; 0x7a0 <Timer_Set_Prescaler+0x18>
 79e:	af c0       	rjmp	.+350    	; 0x8fe <__stack+0x9f>
 7a0:	fc 01       	movw	r30, r24
 7a2:	e6 5d       	subi	r30, 0xD6	; 214
 7a4:	ff 4f       	sbci	r31, 0xFF	; 255
 7a6:	0c 94 d2 05 	jmp	0xba4	; 0xba4 <__tablejump2__>
			{
				case CLK_SOURCE_DISCONNECTED:
				{
					CLR_BIT(TCCR0,CS00);
 7aa:	83 b7       	in	r24, 0x33	; 51
 7ac:	8e 7f       	andi	r24, 0xFE	; 254
 7ae:	83 bf       	out	0x33, r24	; 51
					CLR_BIT(TCCR0,CS01);
 7b0:	83 b7       	in	r24, 0x33	; 51
 7b2:	8d 7f       	andi	r24, 0xFD	; 253
 7b4:	83 bf       	out	0x33, r24	; 51
					CLR_BIT(TCCR0,CS02);
 7b6:	83 b7       	in	r24, 0x33	; 51
 7b8:	8b 7f       	andi	r24, 0xFB	; 251
 7ba:	83 bf       	out	0x33, r24	; 51
				}break;
 7bc:	08 95       	ret
				case PRESCALER_1:
				{
					SET_BIT(TCCR0,CS00);
 7be:	83 b7       	in	r24, 0x33	; 51
 7c0:	81 60       	ori	r24, 0x01	; 1
 7c2:	83 bf       	out	0x33, r24	; 51
					CLR_BIT(TCCR0,CS01);
 7c4:	83 b7       	in	r24, 0x33	; 51
 7c6:	8d 7f       	andi	r24, 0xFD	; 253
 7c8:	83 bf       	out	0x33, r24	; 51
					CLR_BIT(TCCR0,CS02);
 7ca:	83 b7       	in	r24, 0x33	; 51
 7cc:	8b 7f       	andi	r24, 0xFB	; 251
 7ce:	83 bf       	out	0x33, r24	; 51
				}break;
 7d0:	08 95       	ret
				case PRESCALER_8:
				{
					CLR_BIT(TCCR0,CS00);
 7d2:	83 b7       	in	r24, 0x33	; 51
 7d4:	8e 7f       	andi	r24, 0xFE	; 254
 7d6:	83 bf       	out	0x33, r24	; 51
					SET_BIT(TCCR0,CS01);
 7d8:	83 b7       	in	r24, 0x33	; 51
 7da:	82 60       	ori	r24, 0x02	; 2
 7dc:	83 bf       	out	0x33, r24	; 51
					CLR_BIT(TCCR0,CS02);
 7de:	83 b7       	in	r24, 0x33	; 51
 7e0:	8b 7f       	andi	r24, 0xFB	; 251
 7e2:	83 bf       	out	0x33, r24	; 51
				}break;
 7e4:	08 95       	ret
				{
					// do nothing (For timer2 only)
				}break;
				case PRESCALER_64:
				{
					SET_BIT(TCCR0,CS00);
 7e6:	83 b7       	in	r24, 0x33	; 51
 7e8:	81 60       	ori	r24, 0x01	; 1
 7ea:	83 bf       	out	0x33, r24	; 51
					SET_BIT(TCCR0,CS01);
 7ec:	83 b7       	in	r24, 0x33	; 51
 7ee:	82 60       	ori	r24, 0x02	; 2
 7f0:	83 bf       	out	0x33, r24	; 51
					CLR_BIT(TCCR0,CS02);
 7f2:	83 b7       	in	r24, 0x33	; 51
 7f4:	8b 7f       	andi	r24, 0xFB	; 251
 7f6:	83 bf       	out	0x33, r24	; 51
				}break;
 7f8:	08 95       	ret
				{
					// do nothing (For timer2 only)
				}break;
				case PRESCALER_256:
				{
					CLR_BIT(TCCR0,CS00);
 7fa:	83 b7       	in	r24, 0x33	; 51
 7fc:	8e 7f       	andi	r24, 0xFE	; 254
 7fe:	83 bf       	out	0x33, r24	; 51
					CLR_BIT(TCCR0,CS01);
 800:	83 b7       	in	r24, 0x33	; 51
 802:	8d 7f       	andi	r24, 0xFD	; 253
 804:	83 bf       	out	0x33, r24	; 51
					SET_BIT(TCCR0,CS02);
 806:	83 b7       	in	r24, 0x33	; 51
 808:	84 60       	ori	r24, 0x04	; 4
 80a:	83 bf       	out	0x33, r24	; 51
				}break;
 80c:	08 95       	ret
				case PRESCALER_1024:
				{
					SET_BIT(TCCR0,CS00);
 80e:	83 b7       	in	r24, 0x33	; 51
 810:	81 60       	ori	r24, 0x01	; 1
 812:	83 bf       	out	0x33, r24	; 51
					CLR_BIT(TCCR0,CS01);
 814:	83 b7       	in	r24, 0x33	; 51
 816:	8d 7f       	andi	r24, 0xFD	; 253
 818:	83 bf       	out	0x33, r24	; 51
					SET_BIT(TCCR0,CS02);
 81a:	83 b7       	in	r24, 0x33	; 51
 81c:	84 60       	ori	r24, 0x04	; 4
 81e:	83 bf       	out	0x33, r24	; 51
				}break;
 820:	08 95       	ret
				case EXTERNAL_CLK_FAIL_EDGE:
				{
					CLR_BIT(TCCR0,CS00);
 822:	83 b7       	in	r24, 0x33	; 51
 824:	8e 7f       	andi	r24, 0xFE	; 254
 826:	83 bf       	out	0x33, r24	; 51
					SET_BIT(TCCR0,CS01);
 828:	83 b7       	in	r24, 0x33	; 51
 82a:	82 60       	ori	r24, 0x02	; 2
 82c:	83 bf       	out	0x33, r24	; 51
					SET_BIT(TCCR0,CS02);
 82e:	83 b7       	in	r24, 0x33	; 51
 830:	84 60       	ori	r24, 0x04	; 4
 832:	83 bf       	out	0x33, r24	; 51
				}break;
 834:	08 95       	ret
				case EXTERNAL_CLK_RISE_EDGE:
				{
					SET_BIT(TCCR0,CS00);
 836:	83 b7       	in	r24, 0x33	; 51
 838:	81 60       	ori	r24, 0x01	; 1
 83a:	83 bf       	out	0x33, r24	; 51
					SET_BIT(TCCR0,CS01);
 83c:	83 b7       	in	r24, 0x33	; 51
 83e:	82 60       	ori	r24, 0x02	; 2
 840:	83 bf       	out	0x33, r24	; 51
					SET_BIT(TCCR0,CS02);
 842:	83 b7       	in	r24, 0x33	; 51
 844:	84 60       	ori	r24, 0x04	; 4
 846:	83 bf       	out	0x33, r24	; 51
				}break;
 848:	08 95       	ret
			}
		}break;
		case TIMER2:
		{
			switch (prescaler)
 84a:	86 2f       	mov	r24, r22
 84c:	90 e0       	ldi	r25, 0x00	; 0
 84e:	88 30       	cpi	r24, 0x08	; 8
 850:	91 05       	cpc	r25, r1
 852:	08 f0       	brcs	.+2      	; 0x856 <Timer_Set_Prescaler+0xce>
 854:	54 c0       	rjmp	.+168    	; 0x8fe <__stack+0x9f>
 856:	fc 01       	movw	r30, r24
 858:	ec 5c       	subi	r30, 0xCC	; 204
 85a:	ff 4f       	sbci	r31, 0xFF	; 255
 85c:	0c 94 d2 05 	jmp	0xba4	; 0xba4 <__tablejump2__>
			{
				case CLK_SOURCE_DISCONNECTED:
				{
					CLR_BIT(TCCR2,CS20);
 860:	85 b5       	in	r24, 0x25	; 37
 862:	8e 7f       	andi	r24, 0xFE	; 254
 864:	85 bd       	out	0x25, r24	; 37
					CLR_BIT(TCCR2,CS21);
 866:	85 b5       	in	r24, 0x25	; 37
 868:	8d 7f       	andi	r24, 0xFD	; 253
 86a:	85 bd       	out	0x25, r24	; 37
					CLR_BIT(TCCR2,CS22);
 86c:	85 b5       	in	r24, 0x25	; 37
 86e:	8b 7f       	andi	r24, 0xFB	; 251
 870:	85 bd       	out	0x25, r24	; 37
				}break;
 872:	08 95       	ret
				case PRESCALER_1:
				{
					SET_BIT(TCCR2,CS20);
 874:	85 b5       	in	r24, 0x25	; 37
 876:	81 60       	ori	r24, 0x01	; 1
 878:	85 bd       	out	0x25, r24	; 37
					CLR_BIT(TCCR2,CS21);
 87a:	85 b5       	in	r24, 0x25	; 37
 87c:	8d 7f       	andi	r24, 0xFD	; 253
 87e:	85 bd       	out	0x25, r24	; 37
					CLR_BIT(TCCR2,CS22);
 880:	85 b5       	in	r24, 0x25	; 37
 882:	8b 7f       	andi	r24, 0xFB	; 251
 884:	85 bd       	out	0x25, r24	; 37
				}break;
 886:	08 95       	ret
				case PRESCALER_8:
				{
					CLR_BIT(TCCR2,CS20);
 888:	85 b5       	in	r24, 0x25	; 37
 88a:	8e 7f       	andi	r24, 0xFE	; 254
 88c:	85 bd       	out	0x25, r24	; 37
					SET_BIT(TCCR2,CS21);
 88e:	85 b5       	in	r24, 0x25	; 37
 890:	82 60       	ori	r24, 0x02	; 2
 892:	85 bd       	out	0x25, r24	; 37
					CLR_BIT(TCCR2,CS22);
 894:	85 b5       	in	r24, 0x25	; 37
 896:	8b 7f       	andi	r24, 0xFB	; 251
 898:	85 bd       	out	0x25, r24	; 37
				}break;
 89a:	08 95       	ret
				case PRESCALER_32:
				{
					SET_BIT(TCCR2,CS20);
 89c:	85 b5       	in	r24, 0x25	; 37
 89e:	81 60       	ori	r24, 0x01	; 1
 8a0:	85 bd       	out	0x25, r24	; 37
					SET_BIT(TCCR2,CS21);
 8a2:	85 b5       	in	r24, 0x25	; 37
 8a4:	82 60       	ori	r24, 0x02	; 2
 8a6:	85 bd       	out	0x25, r24	; 37
					CLR_BIT(TCCR2,CS22);
 8a8:	85 b5       	in	r24, 0x25	; 37
 8aa:	8b 7f       	andi	r24, 0xFB	; 251
 8ac:	85 bd       	out	0x25, r24	; 37
				}break;
 8ae:	08 95       	ret
				case PRESCALER_64:
				{
					CLR_BIT(TCCR2,CS20);
 8b0:	85 b5       	in	r24, 0x25	; 37
 8b2:	8e 7f       	andi	r24, 0xFE	; 254
 8b4:	85 bd       	out	0x25, r24	; 37
					CLR_BIT(TCCR2,CS21);
 8b6:	85 b5       	in	r24, 0x25	; 37
 8b8:	8d 7f       	andi	r24, 0xFD	; 253
 8ba:	85 bd       	out	0x25, r24	; 37
					SET_BIT(TCCR2,CS22);
 8bc:	85 b5       	in	r24, 0x25	; 37
 8be:	84 60       	ori	r24, 0x04	; 4
 8c0:	85 bd       	out	0x25, r24	; 37
				}break;
 8c2:	08 95       	ret
				case PRESCALER_128:
				{
					SET_BIT(TCCR2,CS20);
 8c4:	85 b5       	in	r24, 0x25	; 37
 8c6:	81 60       	ori	r24, 0x01	; 1
 8c8:	85 bd       	out	0x25, r24	; 37
					CLR_BIT(TCCR2,CS21);
 8ca:	85 b5       	in	r24, 0x25	; 37
 8cc:	8d 7f       	andi	r24, 0xFD	; 253
 8ce:	85 bd       	out	0x25, r24	; 37
					SET_BIT(TCCR2,CS22);
 8d0:	85 b5       	in	r24, 0x25	; 37
 8d2:	84 60       	ori	r24, 0x04	; 4
 8d4:	85 bd       	out	0x25, r24	; 37
				}break;
 8d6:	08 95       	ret
				case PRESCALER_256:
				{
					CLR_BIT(TCCR2,CS20);
 8d8:	85 b5       	in	r24, 0x25	; 37
 8da:	8e 7f       	andi	r24, 0xFE	; 254
 8dc:	85 bd       	out	0x25, r24	; 37
					SET_BIT(TCCR2,CS21);
 8de:	85 b5       	in	r24, 0x25	; 37
 8e0:	82 60       	ori	r24, 0x02	; 2
 8e2:	85 bd       	out	0x25, r24	; 37
					SET_BIT(TCCR2,CS22);
 8e4:	85 b5       	in	r24, 0x25	; 37
 8e6:	84 60       	ori	r24, 0x04	; 4
 8e8:	85 bd       	out	0x25, r24	; 37
				}break;
 8ea:	08 95       	ret
				case PRESCALER_1024:
				{
					SET_BIT(TCCR2,CS20);
 8ec:	85 b5       	in	r24, 0x25	; 37
 8ee:	81 60       	ori	r24, 0x01	; 1
 8f0:	85 bd       	out	0x25, r24	; 37
					SET_BIT(TCCR2,CS21);
 8f2:	85 b5       	in	r24, 0x25	; 37
 8f4:	82 60       	ori	r24, 0x02	; 2
 8f6:	85 bd       	out	0x25, r24	; 37
					SET_BIT(TCCR2,CS22);
 8f8:	85 b5       	in	r24, 0x25	; 37
 8fa:	84 60       	ori	r24, 0x04	; 4
 8fc:	85 bd       	out	0x25, r24	; 37
 8fe:	08 95       	ret

00000900 <Timer_init>:
void (*call_back_fun4)(void);
void (*call_back_fun5)(void);


void Timer_init(TIMER_ID timer_number, TIMER_MODE mode, COMPARE_OUTPUT_MODE oc_pin_state, PRESCALER prescaler)
{
 900:	1f 93       	push	r17
 902:	cf 93       	push	r28
 904:	df 93       	push	r29
 906:	c8 2f       	mov	r28, r24
 908:	14 2f       	mov	r17, r20
 90a:	d2 2f       	mov	r29, r18
	Timer_Set_Mode(timer_number,mode);
 90c:	0e 94 24 03 	call	0x648	; 0x648 <Timer_Set_Mode>
	Timer_Set_COM(timer_number,oc_pin_state);
 910:	61 2f       	mov	r22, r17
 912:	8c 2f       	mov	r24, r28
 914:	0e 94 71 03 	call	0x6e2	; 0x6e2 <Timer_Set_COM>
	Timer_Set_Prescaler(timer_number,prescaler);
 918:	6d 2f       	mov	r22, r29
 91a:	8c 2f       	mov	r24, r28
 91c:	0e 94 c4 03 	call	0x788	; 0x788 <Timer_Set_Prescaler>
}
 920:	df 91       	pop	r29
 922:	cf 91       	pop	r28
 924:	1f 91       	pop	r17
 926:	08 95       	ret

00000928 <Timer_SetTimerStartValue>:
		}break;
	}
}
void Timer_SetTimerStartValue(TIMER_ID timer_number, uint8 start_value)
{
	switch (timer_number)
 928:	88 23       	and	r24, r24
 92a:	19 f0       	breq	.+6      	; 0x932 <Timer_SetTimerStartValue+0xa>
 92c:	81 30       	cpi	r24, 0x01	; 1
 92e:	19 f0       	breq	.+6      	; 0x936 <Timer_SetTimerStartValue+0xe>
 930:	08 95       	ret
	{
		case TIMER0:
		{
			TCNT0 = start_value;
 932:	62 bf       	out	0x32, r22	; 50
		}break;
 934:	08 95       	ret
		case TIMER2:
		{
			TCNT2 = start_value;
 936:	64 bd       	out	0x24, r22	; 36
 938:	08 95       	ret

0000093a <Timer_Disable>:
		}break;
	}
}
void Timer_Disable(TIMER_ID timer_number)
{
	switch (timer_number)
 93a:	88 23       	and	r24, r24
 93c:	19 f0       	breq	.+6      	; 0x944 <Timer_Disable+0xa>
 93e:	81 30       	cpi	r24, 0x01	; 1
 940:	19 f0       	breq	.+6      	; 0x948 <Timer_Disable+0xe>
 942:	08 95       	ret
	{
		case TIMER0:
		{
			TCCR0 = ZER0_INITIALIZER;
 944:	13 be       	out	0x33, r1	; 51
		}break;
 946:	08 95       	ret
		case TIMER2:
		{
			TCCR2 = ZER0_INITIALIZER;
 948:	15 bc       	out	0x25, r1	; 37
 94a:	08 95       	ret

0000094c <__vector_10>:
{
	TCCR1A = ZER0_INITIALIZER;
}

ISR(VECT_TIMER0_COMP)
{
 94c:	1f 92       	push	r1
 94e:	0f 92       	push	r0
 950:	0f b6       	in	r0, 0x3f	; 63
 952:	0f 92       	push	r0
 954:	11 24       	eor	r1, r1
 956:	2f 93       	push	r18
 958:	3f 93       	push	r19
 95a:	4f 93       	push	r20
 95c:	5f 93       	push	r21
 95e:	6f 93       	push	r22
 960:	7f 93       	push	r23
 962:	8f 93       	push	r24
 964:	9f 93       	push	r25
 966:	af 93       	push	r26
 968:	bf 93       	push	r27
 96a:	ef 93       	push	r30
 96c:	ff 93       	push	r31
	call_back_fun1();
 96e:	e0 91 92 00 	lds	r30, 0x0092
 972:	f0 91 93 00 	lds	r31, 0x0093
 976:	09 95       	icall
}
 978:	ff 91       	pop	r31
 97a:	ef 91       	pop	r30
 97c:	bf 91       	pop	r27
 97e:	af 91       	pop	r26
 980:	9f 91       	pop	r25
 982:	8f 91       	pop	r24
 984:	7f 91       	pop	r23
 986:	6f 91       	pop	r22
 988:	5f 91       	pop	r21
 98a:	4f 91       	pop	r20
 98c:	3f 91       	pop	r19
 98e:	2f 91       	pop	r18
 990:	0f 90       	pop	r0
 992:	0f be       	out	0x3f, r0	; 63
 994:	0f 90       	pop	r0
 996:	1f 90       	pop	r1
 998:	18 95       	reti

0000099a <__vector_11>:

ISR(VECT_TIMER0_OVF){
 99a:	1f 92       	push	r1
 99c:	0f 92       	push	r0
 99e:	0f b6       	in	r0, 0x3f	; 63
 9a0:	0f 92       	push	r0
 9a2:	11 24       	eor	r1, r1
 9a4:	2f 93       	push	r18
 9a6:	3f 93       	push	r19
 9a8:	4f 93       	push	r20
 9aa:	5f 93       	push	r21
 9ac:	6f 93       	push	r22
 9ae:	7f 93       	push	r23
 9b0:	8f 93       	push	r24
 9b2:	9f 93       	push	r25
 9b4:	af 93       	push	r26
 9b6:	bf 93       	push	r27
 9b8:	ef 93       	push	r30
 9ba:	ff 93       	push	r31
	call_back_fun2();
 9bc:	e0 91 90 00 	lds	r30, 0x0090
 9c0:	f0 91 91 00 	lds	r31, 0x0091
 9c4:	09 95       	icall
}
 9c6:	ff 91       	pop	r31
 9c8:	ef 91       	pop	r30
 9ca:	bf 91       	pop	r27
 9cc:	af 91       	pop	r26
 9ce:	9f 91       	pop	r25
 9d0:	8f 91       	pop	r24
 9d2:	7f 91       	pop	r23
 9d4:	6f 91       	pop	r22
 9d6:	5f 91       	pop	r21
 9d8:	4f 91       	pop	r20
 9da:	3f 91       	pop	r19
 9dc:	2f 91       	pop	r18
 9de:	0f 90       	pop	r0
 9e0:	0f be       	out	0x3f, r0	; 63
 9e2:	0f 90       	pop	r0
 9e4:	1f 90       	pop	r1
 9e6:	18 95       	reti

000009e8 <__vector_9>:
ISR(VECT_TIMER1_OVF)
{
 9e8:	1f 92       	push	r1
 9ea:	0f 92       	push	r0
 9ec:	0f b6       	in	r0, 0x3f	; 63
 9ee:	0f 92       	push	r0
 9f0:	11 24       	eor	r1, r1
 9f2:	2f 93       	push	r18
 9f4:	3f 93       	push	r19
 9f6:	4f 93       	push	r20
 9f8:	5f 93       	push	r21
 9fa:	6f 93       	push	r22
 9fc:	7f 93       	push	r23
 9fe:	8f 93       	push	r24
 a00:	9f 93       	push	r25
 a02:	af 93       	push	r26
 a04:	bf 93       	push	r27
 a06:	ef 93       	push	r30
 a08:	ff 93       	push	r31
	call_back_fun5();
 a0a:	e0 91 8e 00 	lds	r30, 0x008E
 a0e:	f0 91 8f 00 	lds	r31, 0x008F
 a12:	09 95       	icall
}
 a14:	ff 91       	pop	r31
 a16:	ef 91       	pop	r30
 a18:	bf 91       	pop	r27
 a1a:	af 91       	pop	r26
 a1c:	9f 91       	pop	r25
 a1e:	8f 91       	pop	r24
 a20:	7f 91       	pop	r23
 a22:	6f 91       	pop	r22
 a24:	5f 91       	pop	r21
 a26:	4f 91       	pop	r20
 a28:	3f 91       	pop	r19
 a2a:	2f 91       	pop	r18
 a2c:	0f 90       	pop	r0
 a2e:	0f be       	out	0x3f, r0	; 63
 a30:	0f 90       	pop	r0
 a32:	1f 90       	pop	r1
 a34:	18 95       	reti

00000a36 <__vector_4>:
ISR(VECT_TIMER2_COMP){
 a36:	1f 92       	push	r1
 a38:	0f 92       	push	r0
 a3a:	0f b6       	in	r0, 0x3f	; 63
 a3c:	0f 92       	push	r0
 a3e:	11 24       	eor	r1, r1
 a40:	2f 93       	push	r18
 a42:	3f 93       	push	r19
 a44:	4f 93       	push	r20
 a46:	5f 93       	push	r21
 a48:	6f 93       	push	r22
 a4a:	7f 93       	push	r23
 a4c:	8f 93       	push	r24
 a4e:	9f 93       	push	r25
 a50:	af 93       	push	r26
 a52:	bf 93       	push	r27
 a54:	ef 93       	push	r30
 a56:	ff 93       	push	r31
	call_back_fun3();
 a58:	e0 91 94 00 	lds	r30, 0x0094
 a5c:	f0 91 95 00 	lds	r31, 0x0095
 a60:	09 95       	icall
}
 a62:	ff 91       	pop	r31
 a64:	ef 91       	pop	r30
 a66:	bf 91       	pop	r27
 a68:	af 91       	pop	r26
 a6a:	9f 91       	pop	r25
 a6c:	8f 91       	pop	r24
 a6e:	7f 91       	pop	r23
 a70:	6f 91       	pop	r22
 a72:	5f 91       	pop	r21
 a74:	4f 91       	pop	r20
 a76:	3f 91       	pop	r19
 a78:	2f 91       	pop	r18
 a7a:	0f 90       	pop	r0
 a7c:	0f be       	out	0x3f, r0	; 63
 a7e:	0f 90       	pop	r0
 a80:	1f 90       	pop	r1
 a82:	18 95       	reti

00000a84 <__vector_5>:

ISR(VECT_TIMER2_OVF){
 a84:	1f 92       	push	r1
 a86:	0f 92       	push	r0
 a88:	0f b6       	in	r0, 0x3f	; 63
 a8a:	0f 92       	push	r0
 a8c:	11 24       	eor	r1, r1
 a8e:	2f 93       	push	r18
 a90:	3f 93       	push	r19
 a92:	4f 93       	push	r20
 a94:	5f 93       	push	r21
 a96:	6f 93       	push	r22
 a98:	7f 93       	push	r23
 a9a:	8f 93       	push	r24
 a9c:	9f 93       	push	r25
 a9e:	af 93       	push	r26
 aa0:	bf 93       	push	r27
 aa2:	ef 93       	push	r30
 aa4:	ff 93       	push	r31
	call_back_fun4();
 aa6:	e0 91 96 00 	lds	r30, 0x0096
 aaa:	f0 91 97 00 	lds	r31, 0x0097
 aae:	09 95       	icall
 ab0:	ff 91       	pop	r31
 ab2:	ef 91       	pop	r30
 ab4:	bf 91       	pop	r27
 ab6:	af 91       	pop	r26
 ab8:	9f 91       	pop	r25
 aba:	8f 91       	pop	r24
 abc:	7f 91       	pop	r23
 abe:	6f 91       	pop	r22
 ac0:	5f 91       	pop	r21
 ac2:	4f 91       	pop	r20
 ac4:	3f 91       	pop	r19
 ac6:	2f 91       	pop	r18
 ac8:	0f 90       	pop	r0
 aca:	0f be       	out	0x3f, r0	; 63
 acc:	0f 90       	pop	r0
 ace:	1f 90       	pop	r1
 ad0:	18 95       	reti

00000ad2 <main>:
int main(void)
{
	//SET_BIT(MCUCR,ISC01);
	//ENABLE_EXTERNAL_INT0();
	//GLOBAL_INTERRUPT_ENABLE();
	DIO_Init();
 ad2:	0e 94 28 02 	call	0x450	; 0x450 <DIO_Init>
	Motor_Init();	
 ad6:	0e 94 62 00 	call	0xc4	; 0xc4 <Motor_Init>
	SPI_Init(SLAVE);
 ada:	80 e0       	ldi	r24, 0x00	; 0
 adc:	0e 94 0d 03 	call	0x61a	; 0x61a <SPI_Init>
	uint8 spi_read;
	uint8 motor_for_flag = MOTOR_OFF;
	uint8 motor_back_flag = MOTOR_OFF;
 ae0:	00 e0       	ldi	r16, 0x00	; 0
	//GLOBAL_INTERRUPT_ENABLE();
	DIO_Init();
	Motor_Init();	
	SPI_Init(SLAVE);
	uint8 spi_read;
	uint8 motor_for_flag = MOTOR_OFF;
 ae2:	10 e0       	ldi	r17, 0x00	; 0
					}break;
			case WINDOW_OFF:
			{
				Motor_stop();
				motor_for_flag = MOTOR_OFF;
				motor_back_flag = MOTOR_OFF;
 ae4:	c0 e0       	ldi	r28, 0x00	; 0
					if (motor_for_flag == MOTOR_OFF)
						{
							Motor_set_speed_left(MOTOR_DUTY_CYCLE);
							Motor_set_speed_right(MOTOR_DUTY_CYCLE);
							Motor_move_backward();
							motor_back_flag = MOTOR_ON;
 ae6:	d1 e0       	ldi	r29, 0x01	; 1
	uint8 spi_read;
	uint8 motor_for_flag = MOTOR_OFF;
	uint8 motor_back_flag = MOTOR_OFF;
    while(1)
    {
		spi_read = SPI_Read_Data();
 ae8:	0e 94 20 03 	call	0x640	; 0x640 <SPI_Read_Data>
		
		switch (spi_read)
 aec:	48 2f       	mov	r20, r24
 aee:	50 e0       	ldi	r21, 0x00	; 0
 af0:	47 30       	cpi	r20, 0x07	; 7
 af2:	51 05       	cpc	r21, r1
 af4:	c8 f7       	brcc	.-14     	; 0xae8 <main+0x16>
 af6:	fa 01       	movw	r30, r20
 af8:	e4 5c       	subi	r30, 0xC4	; 196
 afa:	ff 4f       	sbci	r31, 0xFF	; 255
 afc:	0c 94 d2 05 	jmp	0xba4	; 0xba4 <__tablejump2__>
		{
			case LED1_ON:
				{
				DIO_Write(actuator1,HIGH);
 b00:	6d 2f       	mov	r22, r29
 b02:	8c 2f       	mov	r24, r28
 b04:	0e 94 1b 01 	call	0x236	; 0x236 <DIO_Write>
				}break;
 b08:	ef cf       	rjmp	.-34     	; 0xae8 <main+0x16>
			case LED1_OFF:
				{
					DIO_Write(actuator1,LOW);
 b0a:	6c 2f       	mov	r22, r28
 b0c:	8c 2f       	mov	r24, r28
 b0e:	0e 94 1b 01 	call	0x236	; 0x236 <DIO_Write>
				}break;
 b12:	ea cf       	rjmp	.-44     	; 0xae8 <main+0x16>
			case LED2_ON:
				{
					DIO_Write(actuator2,HIGH);
 b14:	6d 2f       	mov	r22, r29
 b16:	8d 2f       	mov	r24, r29
 b18:	0e 94 1b 01 	call	0x236	; 0x236 <DIO_Write>
				}break;
 b1c:	e5 cf       	rjmp	.-54     	; 0xae8 <main+0x16>
			case LED2_OFF:
				{
					DIO_Write(actuator2,LOW);
 b1e:	6c 2f       	mov	r22, r28
 b20:	8d 2f       	mov	r24, r29
 b22:	0e 94 1b 01 	call	0x236	; 0x236 <DIO_Write>
				}break;
 b26:	e0 cf       	rjmp	.-64     	; 0xae8 <main+0x16>
			case WINDOW_OPEN:
				{
					if (motor_back_flag == MOTOR_OFF)
 b28:	01 11       	cpse	r16, r1
 b2a:	0a c0       	rjmp	.+20     	; 0xb40 <main+0x6e>
						{
							Motor_set_speed_left(MOTOR_DUTY_CYCLE);
 b2c:	8e e1       	ldi	r24, 0x1E	; 30
 b2e:	0e 94 83 00 	call	0x106	; 0x106 <Motor_set_speed_left>
							Motor_set_speed_right(MOTOR_DUTY_CYCLE);
 b32:	8e e1       	ldi	r24, 0x1E	; 30
 b34:	0e 94 87 00 	call	0x10e	; 0x10e <Motor_set_speed_right>
							Motor_move_forward();
 b38:	0e 94 69 00 	call	0xd2	; 0xd2 <Motor_move_forward>
							motor_for_flag = MOTOR_ON;
 b3c:	1d 2f       	mov	r17, r29
 b3e:	d4 cf       	rjmp	.-88     	; 0xae8 <main+0x16>
						}
					else if (motor_back_flag == MOTOR_ON)
 b40:	01 30       	cpi	r16, 0x01	; 1
 b42:	91 f6       	brne	.-92     	; 0xae8 <main+0x16>
						{
							Motor_stop();
 b44:	0e 94 8b 00 	call	0x116	; 0x116 <Motor_stop>
							motor_back_flag = MOTOR_OFF;
 b48:	0c 2f       	mov	r16, r28
 b4a:	ce cf       	rjmp	.-100    	; 0xae8 <main+0x16>
						}
				}break;
			case WINDOW_CLOSE:
				{
					if (motor_for_flag == MOTOR_OFF)
 b4c:	11 11       	cpse	r17, r1
 b4e:	0a c0       	rjmp	.+20     	; 0xb64 <main+0x92>
						{
							Motor_set_speed_left(MOTOR_DUTY_CYCLE);
 b50:	8e e1       	ldi	r24, 0x1E	; 30
 b52:	0e 94 83 00 	call	0x106	; 0x106 <Motor_set_speed_left>
							Motor_set_speed_right(MOTOR_DUTY_CYCLE);
 b56:	8e e1       	ldi	r24, 0x1E	; 30
 b58:	0e 94 87 00 	call	0x10e	; 0x10e <Motor_set_speed_right>
							Motor_move_backward();
 b5c:	0e 94 76 00 	call	0xec	; 0xec <Motor_move_backward>
							motor_back_flag = MOTOR_ON;
 b60:	0d 2f       	mov	r16, r29
 b62:	c2 cf       	rjmp	.-124    	; 0xae8 <main+0x16>
						}
					else if (motor_for_flag == MOTOR_ON)
 b64:	11 30       	cpi	r17, 0x01	; 1
 b66:	09 f0       	breq	.+2      	; 0xb6a <main+0x98>
 b68:	bf cf       	rjmp	.-130    	; 0xae8 <main+0x16>
						{
							Motor_stop();
 b6a:	0e 94 8b 00 	call	0x116	; 0x116 <Motor_stop>
							motor_for_flag = MOTOR_OFF;
 b6e:	1c 2f       	mov	r17, r28
 b70:	bb cf       	rjmp	.-138    	; 0xae8 <main+0x16>
						}
					}break;
			case WINDOW_OFF:
			{
				Motor_stop();
 b72:	0e 94 8b 00 	call	0x116	; 0x116 <Motor_stop>
				motor_for_flag = MOTOR_OFF;
				motor_back_flag = MOTOR_OFF;
 b76:	0c 2f       	mov	r16, r28
						}
					}break;
			case WINDOW_OFF:
			{
				Motor_stop();
				motor_for_flag = MOTOR_OFF;
 b78:	1c 2f       	mov	r17, r28
				motor_back_flag = MOTOR_OFF;
			}break;
 b7a:	b6 cf       	rjmp	.-148    	; 0xae8 <main+0x16>

00000b7c <__divmodhi4>:
 b7c:	97 fb       	bst	r25, 7
 b7e:	07 2e       	mov	r0, r23
 b80:	16 f4       	brtc	.+4      	; 0xb86 <__divmodhi4+0xa>
 b82:	00 94       	com	r0
 b84:	07 d0       	rcall	.+14     	; 0xb94 <__divmodhi4_neg1>
 b86:	77 fd       	sbrc	r23, 7
 b88:	09 d0       	rcall	.+18     	; 0xb9c <__divmodhi4_neg2>
 b8a:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <__udivmodhi4>
 b8e:	07 fc       	sbrc	r0, 7
 b90:	05 d0       	rcall	.+10     	; 0xb9c <__divmodhi4_neg2>
 b92:	3e f4       	brtc	.+14     	; 0xba2 <__divmodhi4_exit>

00000b94 <__divmodhi4_neg1>:
 b94:	90 95       	com	r25
 b96:	81 95       	neg	r24
 b98:	9f 4f       	sbci	r25, 0xFF	; 255
 b9a:	08 95       	ret

00000b9c <__divmodhi4_neg2>:
 b9c:	70 95       	com	r23
 b9e:	61 95       	neg	r22
 ba0:	7f 4f       	sbci	r23, 0xFF	; 255

00000ba2 <__divmodhi4_exit>:
 ba2:	08 95       	ret

00000ba4 <__tablejump2__>:
 ba4:	ee 0f       	add	r30, r30
 ba6:	ff 1f       	adc	r31, r31

00000ba8 <__tablejump__>:
 ba8:	05 90       	lpm	r0, Z+
 baa:	f4 91       	lpm	r31, Z
 bac:	e0 2d       	mov	r30, r0
 bae:	09 94       	ijmp

00000bb0 <__udivmodhi4>:
 bb0:	aa 1b       	sub	r26, r26
 bb2:	bb 1b       	sub	r27, r27
 bb4:	51 e1       	ldi	r21, 0x11	; 17
 bb6:	07 c0       	rjmp	.+14     	; 0xbc6 <__udivmodhi4_ep>

00000bb8 <__udivmodhi4_loop>:
 bb8:	aa 1f       	adc	r26, r26
 bba:	bb 1f       	adc	r27, r27
 bbc:	a6 17       	cp	r26, r22
 bbe:	b7 07       	cpc	r27, r23
 bc0:	10 f0       	brcs	.+4      	; 0xbc6 <__udivmodhi4_ep>
 bc2:	a6 1b       	sub	r26, r22
 bc4:	b7 0b       	sbc	r27, r23

00000bc6 <__udivmodhi4_ep>:
 bc6:	88 1f       	adc	r24, r24
 bc8:	99 1f       	adc	r25, r25
 bca:	5a 95       	dec	r21
 bcc:	a9 f7       	brne	.-22     	; 0xbb8 <__udivmodhi4_loop>
 bce:	80 95       	com	r24
 bd0:	90 95       	com	r25
 bd2:	bc 01       	movw	r22, r24
 bd4:	cd 01       	movw	r24, r26
 bd6:	08 95       	ret

00000bd8 <_exit>:
 bd8:	f8 94       	cli

00000bda <__stop_program>:
 bda:	ff cf       	rjmp	.-2      	; 0xbda <__stop_program>
